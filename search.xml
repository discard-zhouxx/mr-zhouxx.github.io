<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>白话Spring（一）：SpringIOC到底是个啥？</title>
    <url>/%E7%99%BD%E8%AF%9DSpring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringIOC%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>Intro:</strong> 学习过Spring框架的人一定都听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，这两个概念还是比较难懂的，所以博主就用大白话的给初学者讲一下这两个概念。</p>
<a id="more"></a>

<p>开门见山，我们先来一个没有IOC的程序例子：</p>
<p>Dao层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserFrominfo</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//操作数据库代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service层代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.UserDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userDao.selectUserFrominfo(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    UserServiceimpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = UserService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    UserController userController;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">        UserDAO dao = <span class="keyword">new</span> UserDAO();</span><br><span class="line">        UserService service = <span class="keyword">new</span> UserService(dao);</span><br><span class="line">        UserController controller = <span class="keyword">new</span> UserController(service);</span><br><span class="line">        controller.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能有的同学要问，这不是挺好的吗？new一下可以实例化，也没浪费多大功夫嘛。</p>
<p>在此回答此问题之前，我们需要了解一个软件工程上的知识点：</p>
<p><strong>耦合度：</strong> 程序之间的依赖关系。我们可以通俗的讲依赖关系就是没有你，我办不成事。人越独立越好，模块也不例外，但是人又不可能完全独立于社会，就像模块不可能完全脱离系统，而消除这种依赖关系的过程就是解耦。</p>
<p>再来看上面的代码，有哪些弊端呢？</p>
<ol>
<li>创建繁琐，每一层我们都需要创建下一层的对象，这个我们能忍，毕竟我们是勤劳勇敢的中国人民，麻烦点不算什么，下面的就不好搞了。</li>
<li>违反面向接口编程的原则，每一层都直接new一个对象，后期更换接口需要工作量爆表。</li>
<li>在这一串调用链中，上层知道下层是如何创建的，上层还需要自己动手创建下层。就好比没有人力资源管理的公司，任何人事的调动都需要该职员的上司进行处理，上下层的耦合性飙升。</li>
<li>开发人员不能专心编写业务逻辑，编写业务逻辑代码时还需要自己连接数据库+自己创建Dao+记住数据库密码。</li>
</ol>
<p>如果使用IOC呢？彻底推翻上述的所有弊端，唯一的缺点就是增加那么一丢丢的学习成本，以及添加那么”亿”丢丢的配置文件。当然这两个缺点第一个是值得的，第二个则被SpringBoot给摆平了。</p>
<p>简单了解IOC有什么用之后，我们再来看IOC到底什么意思。</p>
<p><strong>IOC——控制反转：</strong>有反就有正，所谓的正就是我们在程序中new一个对象出来，我们就开始控制这个对象的生命周期，反转之后呢？<del>这个对象开始控制我们的生命周期</del>（删）我们将对象生命控制权交给Spring，由Spring给我们new对象出来。Spring在这个过程中扮演的就是一个人力资源管理部门的角色，作为大老板的我们应该将精力放到业务逻辑上。 而这些被管理的职员，我们通常称之为Bean。Bean又是什么呢？为什么名字这么奇怪？</p>
<p>Bean这个词并非起源于Spring，只是最近二十年开发者大多都是从Spring中接触到Bean这一名词，Bean的起源年代久远，当初Java还抱着幻想反攻桌面端，但是被微软的VB打的满地找牙。当时微软大推模块化，在IDE中通过拖拽就可以给界面添加各种组件。Java开源社区急了，这种好东西我们也要有，于是大家商量着整出一套规范——JavaBean。通过这个规范就可以让IDE根据反射快速的构建界面，然而没人买账……现在回答Java Bean是什么？Java Bean是一种规范，而Bean就是遵从这个规范的类。你要是问为什么叫Bean而不叫其他什么，那就只能说Java Bean合在一起叫做咖啡豆，起这个名字的人觉得好玩。</p>
<p><strong>Java Bean规范了什么？</strong> 上面说了JavaBean是一种规范，那么规范了什么呢？主要规范了以下四点：</p>
<ol>
<li><p>所有属性使用private</p>
</li>
<li><p>给private标记的属性添加getter/setter方法</p>
</li>
<li><p>实现序列化</p>
</li>
<li><p>具有默认的构造函数（无参的构造函数） </p>
</li>
</ol>
<p>控制反转和我们平常使用的Maven很像，没有Maven的时候，我们需要将所需的依赖包一个个下载好，放到lib文件夹中。有了Maven之后，我们只需要在配置文件中配置上该App所需的所有依赖包，是不是很方便？假如我们需要更换依赖版本，只需要在pom.xml文件中修改版本号，Maven就会自动给我们导入依赖包。相对应的，我们需要更改某一接口的实现类的时候只需要修改注释/配置文件就可以了。</p>
<p>那么怎么告诉Spring这些依赖关系呢？我们可以通过注释或者xml配置文件的方式。</p>
<p><strong>注解方式的IOC：</strong>IOC相关的注解很多，但是总体可以分为两类组件注册和组件加载。</p>
<p>组件注册注解是由@Component注解及其一堆小弟组成的，像业务层的@Service、控制层的@Controller、数据操作层的@Repository。这些小弟可以被@Component代替，但是还是推荐层次更明确的小弟注解。这些注解的作用是告诉Spring哪些类需要你控制，Spring把这些类变成Bean实例，这些实例的名字使用变量类似的驼峰命名法，也就是将类的首字母变为小写，其他不变。注册Bean的过程也就是告诉人力资源部门哪些人是我们公司的职员。当然Spring不知道从哪里找这些组件，你需要在配置文件中配置Spring扫描哪些包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	首先通过context命名空间引入component-scan配置</span></span><br><span class="line"><span class="comment">	component： 组件</span></span><br><span class="line"><span class="comment">	scan： 扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.exmples.*"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样Spring道了哪些包中的组件需要自己管理，又知道这些包中的类需要注册为什么类型。但是这些组件注册之后安排到什么岗位呢？那么就要用到组件加载相关的注解了。</p>
<p>组件加载常用的有@Autowired，@Resource、@Qualifier。@Autowired是Spring中主要使用的注解，它可以通过成员变量/成员变量的setter方法/构造函数将依赖注入。这三个注解有什么区别呢？@Autowired和@Qualifier是Spring中自带的，而@Resource则是在javax.annotation包中。另外@Resource默认是通过名称加载，如果名字找不到，那么就通过类型注入。@Autowired则仅支持通过类型加载的，@Autowired可以和@Qualifier结合使用，可以通过类型和名称双限定加载。至于@Qualifier注解，它一般不单独使用。</p>
<p>我们常用的方式就是@Autowired注解，所以@Resource注解的方式不再演示了。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"dependency"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="comment">//balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calss Exmple&#123;</span><br><span class="line">    <span class="comment">//通过成员变量注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"dependency"</span>)</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exmple</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过setter方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三种注入方法，选择其一即可。这里提一句，不推荐使用成员变量直接注解的方式，而setter和构造方法各有优缺。下面聊聊这三种方式：</p>
<p><strong>字段注入：</strong>又叫属性注入、field注入等等，这种方式代码简洁，编写方便，但是有很多缺点，缺点如下：</p>
<ol>
<li><p>在声明为 final 的字段上不可用，因为final修饰的关键字需要在类实例化的时候进行初始化，这种字段只能使用构造器注入。</p>
</li>
<li><p>与SpringIOC组件耦合，这种方式需要Spring通过反射将属性注入，除此之外没有任何办法（不嫌麻烦你可以使用反射，因为Spring也是这么干的）给这个属性赋值，在你进行单元测试的时候你还要呼叫Spring过来帮你初始化这个依赖，多麻烦呀。就好像你想找小a倒杯水，明明小a就在你隔壁，却还要让人力资源部门通知小a倒水。</p>
</li>
<li><p>隐藏依赖关系，字段注入的方式很简单，一个注解就搞定了。但是简单到让人忘记你到底有多少个依赖，让接手的人不知道哪个才是你的依赖。比如你在公司看到一个不干活的职员，你找人力资源部门说 “这小子哪个部门的？给我开了他！” 结果人力资源部门跟你说，这哥们送外卖的。 </p>
</li>
</ol>
<p><strong>setter方法注入：</strong>这种方式有利有弊，我在小项目开发中一般使用这种方式，因为可以把setter方法藏到最后，代码看起来没那么臃肿。setter唯一的不足就是不能给final依赖注入，但是解决了字段注入的两个缺陷：</p>
<ol>
<li>解除SpringIOC组件的强耦合关系，依赖不仅可以使用Spring注入，也可以通过调用setter方法的方式注入依赖。 </li>
<li>显示依赖关系，通过setter方法上的注释，我们可以知道这个类的依赖关系有哪些，哪些依赖关系需要Spring帮助我i们注入。</li>
</ol>
<p><strong>构造方法注入：</strong>这种注入依赖的方式是Spring官方指定推荐，也就是皇太子（虽然setter注入方式在Spring 3.x 中也是被推荐的那一位）。这种方式几乎没有任何缺点，唯一的缺点就是当你的依赖关系很多的时候，你的构造方法看起来不太美观。碰到这种情况，你就要考虑自己程序设计的是不是有问题了，是不是违背了单一职责原则（如果有机会就把设计原则讲一下，下次一定）呢？细数起来构造方法注入的方式优点如下：</p>
<ol>
<li>允许final关键字修饰的依赖注入，这个没得说，只有这位皇太子有这本事。</li>
<li>依赖检查，重写了有参的构造函数，想实例化这个类就只能通过有参的构造函数完成初始化，万一有个依赖注入失败，那这个类就无法初始化。就好比开会的时候，Spring会告诉你某某某开会没来，这个会开不成，而不是像字段注入和setter方法注入中，让某某某干活了，某某某说我没开会（注入依赖） ，我空指针了。</li>
</ol>
<p>那么构造器注入的方式相较setter方法注入有什么不足呢？setter方法允许类构建之后重新注入。</p>
<p><strong>总结来说：</strong> setter和构造方法各有优劣，每个都有自己不可替代的功能，相较于两位皇子来说，字段注入是不受宠的那个。在实际开发中还是推荐使用构造方法注入的方式。</p>
<p><strong>XML配置文件的注入方式</strong> 讲完注解的方式注入依赖，来看一看开发环境中不是很常用的xml配置文件注入的的方式。XML有两种注入方式，构造器注入和setter方法注入，这两者的优劣类似于注解中两种方式的优劣。</p>
<p>首先来看构造器注入的配置，写在applicationContext.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Denpendency</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中展示了Spring如何创建一个dependency示例并将该实例注入Test中，首先是&lt;bean&gt;标签的讲解，bean标签常用的两个属性id和class，id指定了这个bean在Spring中唯一的标识符，其他bean可以通过id引用该bean，其实相当于java中的标识符（名字！够清楚了吧）。class则指定了这个bean对应的类，也就是告诉Spring哪个类需要注册为id=xxx的bean。这个bean又有哪些属性或者依赖呢？通过&lt;constructor-arg&gt;标签中的两个常用属性value和ref，其中value是没有在Spring中注册的属性（什么是注册请看前面两句刚写的&lt;bean&gt;标签讲解），例如数据库密码、数据库驱动url等等。ref则表示在Spring中注册过的依赖，引用该依赖的方式是ref=“id”。</p>
<p>还是人力资源管理部门的例子，value是公司外的资源，例如隔壁老王送水电话，村头小张仓库地址，这些资源不属于公司内部，没有被人力资源管理部门所管理，但是又被某职工所需要，那么在职工入职（注册为Bean）的时候将这些信息传给这个职工。ref又是个怎么回事呢？ref是公司给你安排的小弟，类似于Controller层，作为高层怎么能没有小弟呢？在空降领导的时候总得带着领导见见小弟吧？ref就是这么回事，你告诉Spring这个领导需要哪些小弟，Spring带着这些小弟<del>注入</del>接见领导，当然这些小弟都需要在Spring中注册过了，不然你还是要用value的方式注入依赖。</p>
<p>看完了XML配置+构造器方法注入之后，再来看XML+setter方法的注入方式。</p>
<p>同样是applicationContext中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，与注解的方式不同，在类中必须有setter方法，否则Spring会报错。至于value和ref什么意思，刚讲过就忘啦？？？？</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="# 写在最后"></a># 写在最后</h2><p>到这里，算是用最直白的话把我理解的Spring IOC和使用方式写出来了，因为本人水平限制，这篇文章一定还有纰漏，希望看官能够指点一下。</p>
<p>因为都是用大白话讲解的，所以涉及的知识难免比较浅薄，目的只是为了帮助初学Spring的同学尽快的了解Spring，具体的深入还是需要大家多多实践。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（一）：SpringBoot入门</title>
    <url>/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringBoot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Spring Boot 可轻松创建一个基于Spring框架的、可运行的、独立的、生产级 Spring 应用程序。（完）</p>
<p>没错，上面那句是我从官网上翻译的。</p>
<p>SpringBoot究竟是何方神圣？Spring开发人员使用SpringBoot之后为何热泪盈眶？JavaEE生态圈为何对SpringBoot狂舔不止？这一切的原因究竟是Spring不够骚了，还是你SpringBoot有点飘了？接下来，欢迎收看我的SpringBoot学习笔记之SpringBoot入门，让我们一起走进SpringBoot的内心世界。</p>
<a id="more"></a>

<h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>记者：您好，SpringBoot，请问您可以简单介绍下自己吗？</p>
<p>SB（SpringBoot的简称）：大家好，我可以轻松创建一个基……</p>
<p>记者：停，能不能简单通俗点说？</p>
<p>SB：啊，大家好，我是Spring全家桶中的一个成员，我今年六岁啦！</p>
<p>记者突然一把扯掉SB的面具，面具下露出Spring的脸。</p>
<p>记者：哼，果然你就是Spring。</p>
<p>SB：才不是呢！我的底层虽然是Spring，但是我更加简单，比如你们说Spring配置文件一大坨，我就尽量给你们自动配置，你们说项目部署到Servlet容器太麻烦了，我就自己内嵌一个Servlet容器，而且开场白我就说了，我可以轻松的构建一个Spring应用……</p>
<p>记者：这样啊，那你都可以做什么呢？</p>
<p>SB：Spring能干的我全都能干，而且更简单，一站式懂吗？就是那种，有我一个人就够了，不用添加什么乱七八糟的依赖、配置文件。</p>
<p>记者：既然你这么优秀，怎么还没取代Spring全家桶呢？</p>
<p>SB：阿这……因为我毕竟是Spring的一种实现方式，这么简单的我，取代Spring是迟早的事，但是单独一个我并不能做什么惊天动地的大事，只有联合我的Spring全家桶中的兄弟姐妹才能在JavaEE圈中称王称霸，毕竟我在Spring生态圈中人缘最好，和第三方框架关系也不错！至于Spring那个老东西，不会还有公司在用吧？不会吧？不会吧？</p>
<p>记者（面向博主）：博主，你被公司开除了。</p>
<p>博主：现在我来总结一下，SpringBoot是Spring的一个变种，其实本质上还是Spring那一套，它可以做到一站式开发，在开发前简化项目依赖，开发过程中简化配置，开发完成后简化部署。不仅能够和Spring全家桶完美契合，还能和主流第三方框架进行整合。乐观地说，SpringBoot取代Spring只是时间问题，然而，SpringBoot使用了大量的Spring提供的API，如果不学习Spring的话，SpringBoot也就只能停留在比较浅的层面。</p>
<h2 id="整一个HelloWorld"><a href="#整一个HelloWorld" class="headerlink" title="整一个HelloWorld"></a>整一个HelloWorld</h2><p>程序员的老规矩，接触新技术先整Helloworld。博主使用的是Idea（别问博主是不是盗版了，学生可以白嫖！！），步骤会一步一步的贴出来，还搞不定的话……放张图与君共勉。<img src="/.top//20200627110835.png" alt="20200627110835"></p>
<p>永远有比我们更惨的人，他都能坚持下去，为什么我们不可以呢？</p>
<p>首先开始第一步，打开我们的idea，创建一个Maven新项目（2020了，不会还有人不知道怎么创建Maven新项目吧？不会吧？）</p>
<p><img src="/.top//image-20200627112301999.png" alt="image-20200627112301999"></p>
<p><img src="/.top//image-20200627112538113.png" alt="image-20200627112538113"></p>
<p><img src="/.top//image-20200627112758857.png" alt="image-20200627112758857"></p>
<p>ok，现在项目创建好了。既然是Maven项目，那么肯定要配置pom.xml文件啦。</p>
<p>打开SpringBoot官网提供了快速开始的配置，那是相当方便啊。知道你们懒，我直接贴在下面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相比SSM框架中导入一大堆依赖来说是不是简单很多？</p>
<p>在main目录下，我们建以下结构，包名自己取，但是欢迎照抄嘿嘿嘿。</p>
<p><img src="/.top//image-20200627142632994.png" alt="image-20200627142632994"></p>
<p>然后再根据下面的结构创建两个类，根包下的类命名需要注意一下，需要写成${项目名}Application：</p>
<p><img src="/.top//image-20200627143809642.png" alt="image-20200627143809642"></p>
<p>在SpringBootDemoApplication类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HelloWorldController类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有小朋友要问了，是不是该配置Tomcat了？SpringBoot不屑一笑，你懂什么叫做可运行吗？</p>
<p>直接运行SpringBootDemoApplication。</p>
<p>看到控制台显示如下：</p>
<p><img src="/.top//image-20200627145252013.png" alt="image-20200627145252013"></p>
<p>这一行中出现了熟悉的字眼——Tomcat，原来SpringBoot自带了一个Tomcat！现在我们去浏览器看一下效果。</p>
<p><img src="/.top//image-20200627145442925.png" alt="image-20200627145442925"></p>
<p>不用一行配置文件，完成HelloWorld，请所有SSM框架的使用者们全体起立，现在这里是SpringBoot广场！开发狂喜，运维狂喜，前端流下羡慕的口水。</p>
<p>HelloWorldController没什么说的，这是SpringMVC中的内容。</p>
<p>值得我们注意的是SpringBootDemoApplication，该类使用了一个叫做@SpringBootApplication的注解，这个注解告诉SpringBoot，这是主配置类。那么@SpringBootApplication是什么呢？</p>
<p>按住Ctrl，左键单击这个注解查看源代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>发现这是一堆注解的组合，前面四个不再详细说，这四个注解表示创建一个注解时这个注解的属性，它们注解的含义和用法可以参考<a href="https://www.jianshu.com/p/8738ce6bd771" target="_blank" rel="noopener">这篇博客</a> 。既然是组合，那么你也可以将后面的注解替代@SpringBootApplication使用，就变成了下面这样。当然，开发环境中你敢这样玩，那你是个狠人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(</span><br><span class="line">                type = FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        ), @<span class="title">ComponentScan</span>.<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">                <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        )&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中需要注意的是@SpringBootConfiguration和@EnableAutoConfiguration。</p>
<p><strong>@SpringBootConfiguration</strong>这个注解表示这个类是SpringBoot的配置类，追踪进去再看这个注解，发现它只有一个注解，那就是@Configuration，这个注解是Spring中的注解，该注解用于表示此类是一个配置类，实锤SpringBoot是Spring的封装版本。</p>
<p><strong>@EnableAutoConfiguration</strong>这个注解是SpringBoot特有的注解，也是SpringBoot和Spring的最大区别之一，从名字就可以看出，这个注解实现了自动配置的功能。</p>
<p>以上知识的详细解释，我在解析SpringBoot底层原理的时候再叭叭，等我们上手使用SpringBoot后，并且对SpringBoot有一定认识的时候再学习底层原理就能事半功倍，刚写完Hello World就搞底层原理，你是个什么神仙？</p>
<h2 id="有没有更简单的HelloWorld"><a href="#有没有更简单的HelloWorld" class="headerlink" title="有没有更简单的HelloWorld?"></a>有没有更简单的HelloWorld?</h2><p>正所谓懒癌改变世界，有的人还觉得上面添加Maven配置太麻烦了，有没有更简单、更迅速构建SpringBoot的方法呢？还真有，除了手撸创建SpringBoot项目外，还有三种方法创建SpringBoot项目。</p>
<ol>
<li>官网下载</li>
<li>STS（Spring推荐的IDE，其实就是Eclipse魔改版）在线构建</li>
<li>Idea在线构建</li>
</ol>
<p>这里仅展示第三种方式，因为我很懒，展示三种实在太难为我了。</p>
<p>首先打开我们的Idea，创建一个新项目。</p>
<p><img src="/.top//image-20200627185206771.png" alt="image-20200627185206771"></p>
<p>然后关键的一步来了</p>
<p><img src="/.top//image-20200627185419061.png" alt="image-20200627185419061"></p>
<p>弹出来一个奇奇怪怪的设置界面</p>
<p><img src="/.top//image-20200627190820425.png" alt="image-20200627190820425"></p>
<p>小声bb：Group填自己的。我已经把上一个项目删掉了，所以我还是上一个项目的名字，你最好换一下。</p>
<p>点击下一步后出现一个乱七八糟的界面，这个界面是选择场景启动器（场景启动器后面再说），先跟着我做</p>
<p><img src="/.top//image-20200627190403890.png" alt="image-20200627190403890"></p>
<p>点击下一步之后到了Idea项目设置的界面，点击完成</p>
<p><img src="/.top//image-20200627190441384.png" alt="image-20200627190441384"></p>
<p>进去之后你会非常惊喜的发现，所有东西都已经配置完成了，只需要创建一个HelloWorldController就可以了，具体的操作我就不再演示了。</p>
<p>上述出现一个新名词叫场景启动器，什么是场景启动器呢？就是SpringBoot将某一场景中所需要用到的依赖打包，例如，我们需要web开发就会在依赖中添加一个叫做spring-boot-starter-web的场景启动器，如果需要测试呢？那么就添加对应的spring-boot-starter-test场景启动器。诸如此类的场景启动器还有很多，不仅有SpringBoot官方的启动器，很多第三方的应用或框架也提供了场景启动器，例如常用的mybatis框架也有SpringBoot的启动器。这些启动器除了打包一堆依赖之外，还添加了一些让人惊喜的小工具，比如web场景启动器内嵌了一个Servlet容器，可以让我们不用再部署到Tomcat。</p>
<h2 id="SpringBoot的配置"><a href="#SpringBoot的配置" class="headerlink" title="SpringBoot的配置"></a>SpringBoot的配置</h2><p>上面讲了SpringBoot开发的到底有多方便，那么问题来了，我该怎么配置SpringBoot呢？比如我要配置Tomcat的监听端口号，总不能让我修改SpringBoot的源码把8080改成80吧？难道还是老样子用xml配置文件？SpringBoot可是说了零xml配置文件。于是SpringBoot默认使用properties文件配置SpringBoot，并且引入了另一种配置文件yml（迷惑行为）。使用这两种全局配置文件来取代SpringBoot中默认的配置。</p>
<p>SpringBoot更加专注于约定，而非配置。什么意思呢？我们先来看一个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的是以spring*.xml的通配符方式加载配置的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是SSM框架中web.xml的一个例子。这里指定了Spring的配置文件的路径以及文件名，web容器通过这个路径和文件名去加载Spring的配置文件，这就是通过配置web.xml来配置组件。而SpringBoot中并没有web.xml文件，那么SpringBoot怎么知道我们的配置文件在哪呢？SpringBoot<strong>约定</strong>了几个目录：</p>
<ol>
<li>recourse目录</li>
<li>recourse目录下的/config目录</li>
<li>项目的根目录</li>
<li>项目根目录下的/config目录</li>
</ol>
<p>并且将文件名也约定好了，全局配置文件名一定要叫application.properties或者application,yml（当然也可以取其他名字，这个后面会讲）。</p>
<p>约定好之后，SpringBoot就可以根据这些目录和文件名进行扫描，排列组合也不过八种情况嘛，这些配置文件也是有优先级的，并且重复配置后，优先级低的配置文件不会覆盖优先级高的配置文件。优先级排序规则如下：</p>
<ol>
<li>项目根目录＞recourse目录</li>
<li>/config目录＞不带/config目录</li>
<li>application.properties&gt;application.yml</li>
</ol>
<p>耐人寻味的是，我们平常最常用的就是recourse目录下的application.yml，嗯……最低优先级。</p>
<p>properties文件相信大家在开发中都使用过，最常用的就是log4j和数据库信息的配置，这里我们就不再赘述了，需要讲解的是yml文件，这个文件看起来和xml有点关系，盲猜下一代配置文件叫zml文件，下面就来讲解yml文件究竟怎么用。</p>
<h3 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h3><p>YML相较于XML更加轻盈，来看一个例子</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">server.host</span>=<span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>三种方式对比后，高下立判。YML使用缩进来表示层级，相较于XML使用标签来表示层级显然更加轻盈，你看这区别像不像Java用大括号界定代码块和Python用缩进界定代码块？哦对，还有lisp圆括号，代码最后一页全都是))))))))))))))))))))))))))))))。相比较properties文件来说分层也更为明显，可读性显然比properties更加优秀，语法上反而和properties一样轻量。</p>
<p>yml的基本语法规则如下：</p>
<ol>
<li>使用缩进表示层级关系</li>
<li>不允许使用tab缩进，只能使用空格（IDE都有自动转换，放心tab）</li>
<li>缩进空格不重要，只要同层级的保持空格数量相同即可，也就是说一个空格就可以表示层级</li>
<li>大小写敏感</li>
<li>基本语法为：key:(空格)value，空格千万必要忘记！</li>
</ol>
<p>yml的value有以下写法：</p>
<ol>
<li><p>字面量：包括字符串、数字、布尔值。字符串默认不需要双引号。</p>
</li>
<li><p>键值对：可以用来表示Map和对象。例如表示server有两个有两种写法：</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="string">&#123;port:</span> <span class="number">8080</span><span class="string">,context:</span> <span class="string">hello&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组：嗯……就数组呗。</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> <span class="string">[pig,cat,dog]</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>这三种数据结构可以任意组合，无限套娃。下面来演示怎么将配置文件读取到Java中。</p>
<h3 id="读取配置文件到Java"><a href="#读取配置文件到Java" class="headerlink" title="读取配置文件到Java"></a>读取配置文件到Java</h3><p>先创建一个类——Cat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Cat&gt; friends;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略一堆getter和setter方法。</span></span><br><span class="line">    <span class="comment">//可以按alt+insert自行插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个类——Host。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编辑application.yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat:</span><br><span class="line">  name: 蓝莓</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">  host:</span><br><span class="line">    name: 周某某</span><br><span class="line">  toys:</span><br><span class="line">    - 毛球</span><br><span class="line">    - 逗猫棒</span><br><span class="line">    - 猫薄荷</span><br><span class="line">    - 周某某的头发</span><br><span class="line">  friends:</span><br><span class="line">    mary: <span class="string">"mary的主人"</span></span><br></pre></td></tr></table></figure>

<p>代码写好了，SpringBoot问你，Cat类是哪个配置文件负责配置的？你说就那个cat:开始的呗，SpringBoot又说了，别的包也有一个Cat类（假装有），我不知道注入哪一个Cat，要不你给我打个注解？好让我知道哪个Cat需要我管理，还有这个Cat是哪段配置文件配置的。</p>
<p>于是拿着SpringBoot给我们的两个注解，@ConfigurationProperties和@Component，放在了Cat的头上，Cat变成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以开始运行了！</p>
<p>还是用我们的HelloWorld类测试运行（也可以使用测试类进行测试。）</p>
<p>编辑HelloWorld类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么这样写可以看我的另一篇博客，白话Spring（一）</span></span><br><span class="line">    <span class="comment">//如果Bean有构造函数，那么可以省略@AutoWired : If a bean has one constructor, you can omit the @Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/.top//image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="读取非全局配置文件到Java"><a href="#读取非全局配置文件到Java" class="headerlink" title="读取非全局配置文件到Java"></a>读取非全局配置文件到Java</h3><p>上面讲到怎么把application.yml配置文件读取到Java中，那如果我有很多配置文件呢？难道都要写进application中嘛？那全局配置文件得多臃肿，修改起来也不方便，所有我们需要将部分配置信息分离出一个单独的文件。</p>
<p>SpringBoot中提供了一个@PropertySource注解，我们先看看这个注解都有什么东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个注解提供了四个值</p>
<ol>
<li>name：名称 默认为空</li>
<li>value：字符串数组，存放需要导入的配置文件路径。</li>
<li>ignoreResourceNotFound：配置文件没找到，要不要告诉你。默认false，也就是告诉你。</li>
<li>encoding：编码方式。</li>
</ol>
<p>通过上面的四个值我们可以看出这个注解可以加载多个配置文件，现在就来实战。</p>
<p>将application.yml重命名为cat.yml，修改Cat类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:cat.yml"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刷新界面，仍旧可以读取。</p>
<p><img src="/.top//image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="SpringBoot多环境下的配置"><a href="#SpringBoot多环境下的配置" class="headerlink" title="SpringBoot多环境下的配置"></a>SpringBoot多环境下的配置</h3><p>上面我说到SpringBoot和我们约定好了一起把全局配置写到名为application文件中，我也提到了可以使用别的名字。那么什么时候我们需要使用别的名字呢？也就是SpringBoot运行环境不同的时候，我们需要不同的配置文件来配置SpringBoot，比如开发环境通常端口号是8080、生产环境端口号看老大心情。我们总不能每次换一个环境就把全局配置文件进行修改吧？估计改个几次配置文件就面目全非，找不到头尾。SpringBoot也不是那么死板的只读取application文件，多一个字少一个字都不行。</p>
<p>SpringBoot允许我们添加多个命名为application-{环境名}.yml的application配置文件。</p>
<p>例如：开发环境可以命名为：application-dev.yml或者application-dev.properties；生产环境可以命名为：application-proc.yml；测试环境可以命名为：application-test.yml</p>
<p>我们先创建上面三个不同环境下的application配置文件，分别给这三个配置文件写上：</p>
<p>application-dev.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>application-proc.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7777</span></span><br></pre></td></tr></table></figure>

<p>application-test.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>对了，还有不带后缀的配置文件application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行，SpringBoot会使用不带后缀的配置文件来配置SpringBoot。</p>
<p><img src="/.top//image-20200629115552251.png" alt="image-20200629115552251"></p>
<p>可以看到端口号是application.yml中所配置的端口号。</p>
<p>怎么告诉SpringBoot本次运行需要使用哪个配置文件呢？有以下几种方式：</p>
<ol>
<li><p>修改默认配置文件：</p>
<p> 在application.yml文件中添加</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p> 这里指定了使用后缀名为dev的配置文件，运行后结果：</p>
<p> <img src="/.top//image-20200629120126819.png" alt="image-20200629120126819"></p>
<p> 也就是SpringBoot会先去application.yml中看spring.profiles.active是否配置了另一个全局配置文件，如果配置了，就只使用相应后缀的配置文件。</p>
</li>
<li><p>命令行模式：</p>
<p> 运行时直接加在运行jar包命令的后面 –spring.profiles.active=proc，这种方式牵扯到SpringBoot的打包和运行，不过我们在IDEA中也可以使用增加选项的方式来测试。</p>
<p> <img src="/.top//image-20200629121313373.png" alt="image-20200629121313373"></p>
<p> 在配置环境中添加–spring.profiles.active=proc（意思为生产环境）</p>
<p> <img src="/.top//image-20200629121913696.png" alt="image-20200629121913696"></p>
<p> 运行之后结果：</p>
<p> <img src="/.top//image-20200629122015786.png" alt="image-20200629122015786"></p>
<p> 等等？我们在application.yml中配置了使用dev后缀的配置文件，命令行配置了proc后缀的配置文件，然而现在SpringBoot使用了proc的配置，OK，命令行方式会覆盖application中的配置。</p>
</li>
<li><p>虚拟机参数：</p>
</li>
</ol>
<pre><code>![image-20200629121313373](image-20200629121313373.png)

在vm选项中添加-Dspring.profiles.active=test</code></pre><p><img src="/.top//image-20200629122816187.png" alt="image-20200629122816187"></p>
<p>运行之后：</p>
<p><img src="/.top//image-20200629122015786.png" alt="image-20200629122015786"></p>
<p>嗯？怎么还是proc的端口？命令行选项没有删除，也就是命令行优先级高于虚拟机配置，把命令行选项删除，再次运行。</p>
<p><img src="/.top//image-20200629123135251.png" alt="image-20200629123135251"></p>
<p>这个就是test的端口号了，但是别忘了application.yml中的配置文件从来都没有删除过spring.profiles.active=dev这个配置项。</p>
<p>所以这三种配置的优先级是：命令行选项 &gt; 虚拟机选项 &gt; application中配置</p>
<h2 id="SpringBoot注册组件"><a href="#SpringBoot注册组件" class="headerlink" title="SpringBoot注册组件"></a>SpringBoot注册组件</h2><p>SpringBoot虽然可以使用@ImportRecourse注解导入Spring的xml配置文件（也就是创建Bean），但是SpringBoot不推荐这种办法，而是使用配置类来添加组件。</p>
<p>首先需要告诉SpringBoot这是一个配置类也就是前面讲过的@Configuration注解，SpringBoot会在扫描的时候将这个配置类添加到自己的小本本里。SpringBoot得知这是个配置类之后，你需要告诉它这个配置类是做什么的，Spring提供了一个注解@Bean，这个注解标注在一个方法上，它会将标注方法的返回值注册进容器。</p>
<p>来看一个例子：</p>
<p>根包目录下创建一个config包，并创建一个ConfigDemo类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//标注为配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Host <span class="title">host</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值类型是要注册的组件类，方法名是该组件在SpringBoot中的id</span></span><br><span class="line">        System.out.println(<span class="string">"创建Host成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Host(<span class="string">"小王"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再魔改一下我们的HelloWorld类（controller包中的，曾经的HelloWorld成为了我们的测试类……）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入组件</span></span><br><span class="line">    <span class="keyword">final</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后结果如下：</p>
<p>控制台：</p>
<p><img src="/.top//image-20200629101604813.png" alt="image-20200629101604813"></p>
<p>浏览器：</p>
<p><img src="/.top//image-20200629101623161.png" alt="image-20200629101623161"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于写完了……不算图一共五千字（废话有三千字），不知道有没有人能耐心看完……</p>
<p>先来总结下知识点：</p>
<ol>
<li>SpringBoot是什么？</li>
<li>HelloWorld怎么写？</li>
<li>如何通过Spring向导创建SpringBoot项目？</li>
<li>YML的基本语法以及怎么解析YML到Java？</li>
<li>全局配置文件的优先级</li>
<li>解析非全局配置文件到Java</li>
<li>SpringBoot读取不同环境下的全局配置文件的三种方式及优先级</li>
<li>通过配置类的方式注册组件到SpringBoot</li>
</ol>
<p>如果你看着这八条能够想起来步骤，那么这篇博客已经完成了它的使命，有任何不解请联系我，有问必答。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
