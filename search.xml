<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>白话Spring（一）：SpringIOC到底是个啥？</title>
    <url>/%E7%99%BD%E8%AF%9DSpring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringIOC%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>INTRO:</strong> 学习过Spring框架的人一定都听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，这两个概念还是比较难懂的，所以博主就用大白话的给初学者讲一下这两个概念。</p>
<a id="more"></a>

<p>开门见山，我们先来一个没有IOC的程序例子：</p>
<p>Dao层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserFrominfo</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//操作数据库代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service层代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.UserDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userDao.selectUserFrominfo(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    UserServiceimpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = UserService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    UserController userController;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">        UserDAO dao = <span class="keyword">new</span> UserDAO();</span><br><span class="line">        UserService service = <span class="keyword">new</span> UserService(dao);</span><br><span class="line">        UserController controller = <span class="keyword">new</span> UserController(service);</span><br><span class="line">        controller.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能有的同学要问，这不是挺好的吗？new一下可以实例化，也没浪费多大功夫嘛。</p>
<p>在此回答此问题之前，我们需要了解一个软件工程上的知识点：</p>
<p><strong>耦合度：</strong> 程序之间的依赖关系。我们可以通俗的讲依赖关系就是没有你，我办不成事。人越独立越好，模块也不例外，但是人又不可能完全独立于社会，就像模块不可能完全脱离系统，而消除这种依赖关系的过程就是解耦。</p>
<p>再来看上面的代码，有哪些弊端呢？</p>
<ol>
<li>创建繁琐，每一层我们都需要创建下一层的对象，这个我们能忍，毕竟我们是勤劳勇敢的中国人民，麻烦点不算什么，下面的就不好搞了。</li>
<li>违反面向接口编程的原则，每一层都直接new一个对象，后期更换接口需要工作量爆表。</li>
<li>在这一串调用链中，上层知道下层是如何创建的，上层还需要自己动手创建下层。就好比没有人力资源管理的公司，任何人事的调动都需要该职员的上司进行处理，上下层的耦合性飙升。</li>
<li>开发人员不能专心编写业务逻辑，编写业务逻辑代码时还需要自己连接数据库+自己创建Dao+记住数据库密码。</li>
</ol>
<p>如果使用IOC呢？彻底推翻上述的所有弊端，唯一的缺点就是增加那么一丢丢的学习成本，以及添加那么”亿”丢丢的配置文件。当然这两个缺点第一个是值得的，第二个则被SpringBoot给摆平了。</p>
<p>简单了解IOC有什么用之后，我们再来看IOC到底什么意思。</p>
<p><strong>IOC——控制反转：</strong>有反就有正，所谓的正就是我们在程序中new一个对象出来，我们就开始控制这个对象的生命周期，反转之后呢？<del>这个对象开始控制我们的生命周期</del>（删）我们将对象生命控制权交给Spring，由Spring给我们new对象出来。Spring在这个过程中扮演的就是一个人力资源管理部门的角色，作为大老板的我们应该将精力放到业务逻辑上。 而这些被管理的职员，我们通常称之为Bean。Bean又是什么呢？为什么名字这么奇怪？</p>
<p>Bean这个词并非起源于Spring，只是最近二十年开发者大多都是从Spring中接触到Bean这一名词，Bean的起源年代久远，当初Java还抱着幻想反攻桌面端，但是被微软的VB打的满地找牙。当时微软大推模块化，在IDE中通过拖拽就可以给界面添加各种组件。Java开源社区急了，这种好东西我们也要有，于是大家商量着整出一套规范——JavaBean。通过这个规范就可以让IDE根据反射快速的构建界面，然而没人买账……现在回答Java Bean是什么？Java Bean是一种规范，而Bean就是遵从这个规范的类。你要是问为什么叫Bean而不叫其他什么，那就只能说Java Bean合在一起叫做咖啡豆，起这个名字的人觉得好玩。</p>
<p><strong>Java Bean规范了什么？</strong> 上面说了JavaBean是一种规范，那么规范了什么呢？主要规范了以下四点：</p>
<ol>
<li><p>所有属性使用private</p>
</li>
<li><p>给private标记的属性添加getter/setter方法</p>
</li>
<li><p>实现序列化</p>
</li>
<li><p>具有默认的构造函数（无参的构造函数） </p>
</li>
</ol>
<p>控制反转和我们平常使用的Maven很像，没有Maven的时候，我们需要将所需的依赖包一个个下载好，放到lib文件夹中。有了Maven之后，我们只需要在配置文件中配置上该App所需的所有依赖包，是不是很方便？假如我们需要更换依赖版本，只需要在pom.xml文件中修改版本号，Maven就会自动给我们导入依赖包。相对应的，我们需要更改某一接口的实现类的时候只需要修改注释/配置文件就可以了。</p>
<p>那么怎么告诉Spring这些依赖关系呢？我们可以通过注释或者xml配置文件的方式。</p>
<p><strong>注解方式的IOC：</strong>IOC相关的注解很多，但是总体可以分为两类组件注册和组件加载。</p>
<p>组件注册注解是由@Component注解及其一堆小弟组成的，像业务层的@Service、控制层的@Controller、数据操作层的@Repository。这些小弟可以被@Component代替，但是还是推荐层次更明确的小弟注解。这些注解的作用是告诉Spring哪些类需要你控制，Spring把这些类变成Bean实例，这些实例的名字使用变量类似的驼峰命名法，也就是将类的首字母变为小写，其他不变。注册Bean的过程也就是告诉人力资源部门哪些人是我们公司的职员。当然Spring不知道从哪里找这些组件，你需要在配置文件中配置Spring扫描哪些包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	首先通过context命名空间引入component-scan配置</span></span><br><span class="line"><span class="comment">	component： 组件</span></span><br><span class="line"><span class="comment">	scan： 扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.exmples.*"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样Spring道了哪些包中的组件需要自己管理，又知道这些包中的类需要注册为什么类型。但是这些组件注册之后安排到什么岗位呢？那么就要用到组件加载相关的注解了。</p>
<p>组件加载常用的有@Autowired，@Resource、@Qualifier。@Autowired是Spring中主要使用的注解，它可以通过成员变量/成员变量的setter方法/构造函数将依赖注入。这三个注解有什么区别呢？@Autowired和@Qualifier是Spring中自带的，而@Resource则是在javax.annotation包中。另外@Resource默认是通过名称加载，如果名字找不到，那么就通过类型注入。@Autowired则仅支持通过类型加载的，@Autowired可以和@Qualifier结合使用，可以通过类型和名称双限定加载。至于@Qualifier注解，它一般不单独使用。</p>
<p>我们常用的方式就是@Autowired注解，所以@Resource注解的方式不再演示了。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"dependency"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="comment">//balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calss Exmple&#123;</span><br><span class="line">    <span class="comment">//通过成员变量注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"dependency"</span>)</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exmple</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过setter方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三种注入方法，选择其一即可。这里提一句，不推荐使用成员变量直接注解的方式，而setter和构造方法各有优缺。下面聊聊这三种方式：</p>
<p><strong>字段注入：</strong>又叫属性注入、field注入等等，这种方式代码简洁，编写方便，但是有很多缺点，缺点如下：</p>
<ol>
<li><p>在声明为 final 的字段上不可用，因为final修饰的关键字需要在类实例化的时候进行初始化，这种字段只能使用构造器注入。</p>
</li>
<li><p>与SpringIOC组件耦合，这种方式需要Spring通过反射将属性注入，除此之外没有任何办法（不嫌麻烦你可以使用反射，因为Spring也是这么干的）给这个属性赋值，在你进行单元测试的时候你还要呼叫Spring过来帮你初始化这个依赖，多麻烦呀。就好像你想找小a倒杯水，明明小a就在你隔壁，却还要让人力资源部门通知小a倒水。</p>
</li>
<li><p>隐藏依赖关系，字段注入的方式很简单，一个注解就搞定了。但是简单到让人忘记你到底有多少个依赖，让接手的人不知道哪个才是你的依赖。比如你在公司看到一个不干活的职员，你找人力资源部门说 “这小子哪个部门的？给我开了他！” 结果人力资源部门跟你说，这哥们送外卖的。 </p>
</li>
</ol>
<p><strong>setter方法注入：</strong>这种方式有利有弊，我在小项目开发中一般使用这种方式，因为可以把setter方法藏到最后，代码看起来没那么臃肿。setter唯一的不足就是不能给final依赖注入，但是解决了字段注入的两个缺陷：</p>
<ol>
<li>解除SpringIOC组件的强耦合关系，依赖不仅可以使用Spring注入，也可以通过调用setter方法的方式注入依赖。 </li>
<li>显示依赖关系，通过setter方法上的注释，我们可以知道这个类的依赖关系有哪些，哪些依赖关系需要Spring帮助我i们注入。</li>
</ol>
<p><strong>构造方法注入：</strong>这种注入依赖的方式是Spring官方指定推荐，也就是皇太子（虽然setter注入方式在Spring 3.x 中也是被推荐的那一位）。这种方式几乎没有任何缺点，唯一的缺点就是当你的依赖关系很多的时候，你的构造方法看起来不太美观。碰到这种情况，你就要考虑自己程序设计的是不是有问题了，是不是违背了单一职责原则（如果有机会就把设计原则讲一下，下次一定）呢？细数起来构造方法注入的方式优点如下：</p>
<ol>
<li>允许final关键字修饰的依赖注入，这个没得说，只有这位皇太子有这本事。</li>
<li>依赖检查，重写了有参的构造函数，想实例化这个类就只能通过有参的构造函数完成初始化，万一有个依赖注入失败，那这个类就无法初始化。就好比开会的时候，Spring会告诉你某某某开会没来，这个会开不成，而不是像字段注入和setter方法注入中，让某某某干活了，某某某说我没开会（注入依赖） ，我空指针了。</li>
</ol>
<p>那么构造器注入的方式相较setter方法注入有什么不足呢？setter方法允许类构建之后重新注入。</p>
<p><strong>总结来说：</strong> setter和构造方法各有优劣，每个都有自己不可替代的功能，相较于两位皇子来说，字段注入是不受宠的那个。在实际开发中还是推荐使用构造方法注入的方式。</p>
<p><strong>XML配置文件的注入方式</strong> 讲完注解的方式注入依赖，来看一看开发环境中不是很常用的xml配置文件注入的的方式。XML有两种注入方式，构造器注入和setter方法注入，这两者的优劣类似于注解中两种方式的优劣。</p>
<p>首先来看构造器注入的配置，写在applicationContext.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Denpendency</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中展示了Spring如何创建一个dependency示例并将该实例注入Test中，首先是&lt;bean&gt;标签的讲解，bean标签常用的两个属性id和class，id指定了这个bean在Spring中唯一的标识符，其他bean可以通过id引用该bean，其实相当于java中的标识符（名字！够清楚了吧）。class则指定了这个bean对应的类，也就是告诉Spring哪个类需要注册为id=xxx的bean。这个bean又有哪些属性或者依赖呢？通过&lt;constructor-arg&gt;标签中的两个常用属性value和ref，其中value是没有在Spring中注册的属性（什么是注册请看前面两句刚写的&lt;bean&gt;标签讲解），例如数据库密码、数据库驱动url等等。ref则表示在Spring中注册过的依赖，引用该依赖的方式是ref=“id”。</p>
<p>还是人力资源管理部门的例子，value是公司外的资源，例如隔壁老王送水电话，村头小张仓库地址，这些资源不属于公司内部，没有被人力资源管理部门所管理，但是又被某职工所需要，那么在职工入职（注册为Bean）的时候将这些信息传给这个职工。ref又是个怎么回事呢？ref是公司给你安排的小弟，类似于Controller层，作为高层怎么能没有小弟呢？在空降领导的时候总得带着领导见见小弟吧？ref就是这么回事，你告诉Spring这个领导需要哪些小弟，Spring带着这些小弟<del>注入</del>接见领导，当然这些小弟都需要在Spring中注册过了，不然你还是要用value的方式注入依赖。</p>
<p>看完了XML配置+构造器方法注入之后，再来看XML+setter方法的注入方式。</p>
<p>同样是applicationContext中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，与注解的方式不同，在类中必须有setter方法，否则Spring会报错。至于value和ref什么意思，刚讲过就忘啦？？？？</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="# 写在最后"></a># 写在最后</h2><p>到这里，算是用最直白的话把我理解的Spring IOC和使用方式写出来了，因为本人水平限制，这篇文章一定还有纰漏，希望看官能够指点一下。</p>
<p>因为都是用大白话讲解的，所以涉及的知识难免比较浅薄，目的只是为了帮助初学Spring的同学尽快的了解Spring，具体的深入还是需要大家多多实践。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（一）：SpringBoot入门</title>
    <url>/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringBoot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> SpringBoot究竟是何方神圣？Spring开发人员使用SpringBoot之后为何热泪盈眶？JavaEE生态圈为何对SpringBoot狂舔不止？这一切的原因究竟是Spring不够骚了，还是你SpringBoot有点飘了？接下来，欢迎收看我的SpringBoot学习笔记之SpringBoot入门，让我们一起走进SpringBoot的内心世界。</p>
<a id="more"></a>

<h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>记者：您好，SpringBoot，请问您可以简单介绍下自己吗？</p>
<p>SB（SpringBoot的简称）：大家好，我可以轻松创建一个基……</p>
<p>记者：停，能不能简单通俗点说？</p>
<p>SB：啊，大家好，我是Spring全家桶中的一个成员，我今年六岁啦！</p>
<p>记者突然一把扯掉SB的面具，面具下露出Spring的脸。</p>
<p>记者：哼，果然你就是Spring。</p>
<p>SB：才不是呢！我的底层虽然是Spring，但是我更加简单，比如你们说Spring配置文件一大坨，我就尽量给你们自动配置，你们说项目部署到Servlet容器太麻烦了，我就自己内嵌一个Servlet容器，而且开场白我就说了，我可以轻松的构建一个Spring应用……</p>
<p>记者：这样啊，那你都可以做什么呢？</p>
<p>SB：Spring能干的我全都能干，而且更简单，一站式懂吗？就是那种，有我一个人就够了，不用添加什么乱七八糟的依赖、配置文件。</p>
<p>记者：既然你这么优秀，怎么还没取代Spring全家桶呢？</p>
<p>SB：阿这……因为我毕竟是Spring的一种实现方式，这么简单的我，取代Spring是迟早的事，但是单独一个我并不能做什么惊天动地的大事，只有联合我的Spring全家桶中的兄弟姐妹才能在JavaEE圈中称王称霸，毕竟我在Spring生态圈中人缘最好，和第三方框架关系也不错！至于Spring那个老东西，不会还有公司在用吧？不会吧？不会吧？</p>
<p>记者（面向博主）：博主，你被公司开除了。</p>
<p>博主：现在我来总结一下，SpringBoot是Spring的一个变种，其实本质上还是Spring那一套，它可以做到一站式开发，在开发前简化项目依赖，开发过程中简化配置，开发完成后简化部署。不仅能够和Spring全家桶完美契合，还能和主流第三方框架进行整合。乐观地说，SpringBoot取代Spring只是时间问题，然而，SpringBoot使用了大量的Spring提供的API，如果不学习Spring的话，SpringBoot也就只能停留在比较浅的层面。</p>
<h2 id="整一个HelloWorld"><a href="#整一个HelloWorld" class="headerlink" title="整一个HelloWorld"></a>整一个HelloWorld</h2><p>程序员的老规矩，接触新技术先整Helloworld。博主使用的是Idea（别问博主是不是盗版了，学生可以白嫖！！），步骤会一步一步的贴出来，还搞不定的话……放张图与君共勉。<img src="https://gitee.com/vanbyz/images/raw/master/img/20200627110835.png" alt="20200627110835"></p>
<p>永远有比我们更惨的人，他都能坚持下去，为什么我们不可以呢？</p>
<p>首先开始第一步，打开我们的idea，创建一个Maven新项目（2020了，不会还有人不知道怎么创建Maven新项目吧？不会吧？）</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112301999.png" alt="image-20200627112301999"></p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112538113.png" alt="image-20200627112538113"></p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112758857.png" alt="image-20200627112758857">    ok，现在项目创建好了。既然是Maven项目，那么肯定要配置pom.xml文件啦。</p>
<p>打开SpringBoot官网提供了快速开始的配置，那是相当方便啊。知道你们懒，我直接贴在下面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相比SSM框架中导入一大堆依赖来说是不是简单很多？</p>
<p>在main目录下，我们建以下结构，包名自己取，但是欢迎照抄嘿嘿嘿。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627142632994.png" alt="image-20200627142632994"></p>
<p>然后再根据下面的结构创建两个类，根包下的类命名需要注意一下，需要写成${项目名}Application：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627143809642.png" alt="image-20200627143809642"></p>
<p>在SpringBootDemoApplication类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HelloWorldController类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有小朋友要问了，是不是该配置Tomcat了？SpringBoot不屑一笑，你懂什么叫做可运行吗？</p>
<p>直接运行SpringBootDemoApplication。</p>
<p>看到控制台显示如下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627145252013.png" alt="image-20200627145252013"></p>
<p>这一行中出现了熟悉的字眼——Tomcat，原来SpringBoot自带了一个Tomcat！现在我们去浏览器看一下效果。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627145442925.png" alt="image-20200627145442925"></p>
<p>不用一行配置文件，完成HelloWorld，请所有SSM框架的使用者们全体起立，现在这里是SpringBoot广场！开发狂喜，运维狂喜，前端流下羡慕的口水。</p>
<p>HelloWorldController没什么说的，这是SpringMVC中的内容。</p>
<p>值得我们注意的是SpringBootDemoApplication，该类使用了一个叫做@SpringBootApplication的注解，这个注解告诉SpringBoot，这是主配置类。那么@SpringBootApplication是什么呢？</p>
<p>按住Ctrl，左键单击这个注解查看源代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>发现这是一堆注解的组合，前面四个不再详细说，这四个注解表示创建一个注解时这个注解的属性，它们注解的含义和用法可以参考<a href="https://www.jianshu.com/p/8738ce6bd771" target="_blank" rel="noopener">这篇博客</a> 。既然是组合，那么你也可以将后面的注解替代@SpringBootApplication使用，就变成了下面这样。当然，开发环境中你敢这样玩，那你是个狠人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(</span><br><span class="line">                type = FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        ), @<span class="title">ComponentScan</span>.<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">                <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        )&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中需要注意的是@SpringBootConfiguration和@EnableAutoConfiguration。</p>
<p><strong>@SpringBootConfiguration</strong>这个注解表示这个类是SpringBoot的配置类，追踪进去再看这个注解，发现它只有一个注解，那就是@Configuration，这个注解是Spring中的注解，该注解用于表示此类是一个配置类，实锤SpringBoot是Spring的封装版本。</p>
<p><strong>@EnableAutoConfiguration</strong>这个注解是SpringBoot特有的注解，也是SpringBoot和Spring的最大区别之一，从名字就可以看出，这个注解实现了自动配置的功能。</p>
<p>以上知识的详细解释，我在解析SpringBoot底层原理的时候再叭叭，等我们上手使用SpringBoot后，并且对SpringBoot有一定认识的时候再学习底层原理就能事半功倍，刚写完Hello World就搞底层原理，你是个什么神仙？</p>
<h2 id="有没有更简单的HelloWorld"><a href="#有没有更简单的HelloWorld" class="headerlink" title="有没有更简单的HelloWorld?"></a>有没有更简单的HelloWorld?</h2><p>正所谓懒癌改变世界，有的人还觉得上面添加Maven配置太麻烦了，有没有更简单、更迅速构建SpringBoot的方法呢？还真有，除了手撸创建SpringBoot项目外，还有三种方法创建SpringBoot项目。</p>
<ol>
<li>官网下载</li>
<li>STS（Spring推荐的IDE，其实就是Eclipse魔改版）在线构建</li>
<li>Idea在线构建</li>
</ol>
<p>这里仅展示第三种方式，因为我很懒，展示三种实在太难为我了。</p>
<p>首先打开我们的Idea，创建一个新项目。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627185206771.png" alt="image-20200627185206771"></p>
<p>然后关键的一步来了</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627185419061.png" alt="image-20200627185419061"></p>
<p>弹出来一个奇奇怪怪的设置界面</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190820425.png" alt="image-20200627190820425"></p>
<p>小声bb：Group填自己的。我已经把上一个项目删掉了，所以我还是上一个项目的名字，你最好换一下。</p>
<p>点击下一步后出现一个乱七八糟的界面，这个界面是选择场景启动器（场景启动器后面再说），先跟着我做</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190403890.png" alt="image-20200627190403890"></p>
<p>点击下一步之后到了Idea项目设置的界面，点击完成</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190441384.png" alt="image-20200627190441384"></p>
<p>进去之后你会非常惊喜的发现，所有东西都已经配置完成了，只需要创建一个HelloWorldController就可以了，具体的操作我就不再演示了。</p>
<p>上述出现一个新名词叫场景启动器，什么是场景启动器呢？就是SpringBoot将某一场景中所需要用到的依赖打包，例如，我们需要web开发就会在依赖中添加一个叫做spring-boot-starter-web的场景启动器，如果需要测试呢？那么就添加对应的spring-boot-starter-test场景启动器。诸如此类的场景启动器还有很多，不仅有SpringBoot官方的启动器，很多第三方的应用或框架也提供了场景启动器，例如常用的mybatis框架也有SpringBoot的启动器。这些启动器除了打包一堆依赖之外，还添加了一些让人惊喜的小工具，比如web场景启动器内嵌了一个Servlet容器，可以让我们不用再部署到Tomcat。</p>
<h2 id="SpringBoot的配置"><a href="#SpringBoot的配置" class="headerlink" title="SpringBoot的配置"></a>SpringBoot的配置</h2><p>上面讲了SpringBoot开发的到底有多方便，那么问题来了，我该怎么配置SpringBoot呢？比如我要配置Tomcat的监听端口号，总不能让我修改SpringBoot的源码把8080改成80吧？难道还是老样子用xml配置文件？SpringBoot可是说了零xml配置文件。于是SpringBoot默认使用properties文件配置SpringBoot，并且引入了另一种配置文件yml（迷惑行为）。使用这两种全局配置文件来取代SpringBoot中默认的配置。</p>
<p>SpringBoot更加专注于约定，而非配置。什么意思呢？我们先来看一个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的是以spring*.xml的通配符方式加载配置的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是SSM框架中web.xml的一个例子。这里指定了Spring的配置文件的路径以及文件名，web容器通过这个路径和文件名去加载Spring的配置文件，这就是通过配置web.xml来配置组件。而SpringBoot中并没有web.xml文件，那么SpringBoot怎么知道我们的配置文件在哪呢？SpringBoot<strong>约定</strong>了几个目录：</p>
<ol>
<li>recourse目录</li>
<li>recourse目录下的/config目录</li>
<li>项目的根目录</li>
<li>项目根目录下的/config目录</li>
</ol>
<p>并且将文件名也约定好了，全局配置文件名一定要叫application.properties或者application,yml（当然也可以取其他名字，这个后面会讲）。</p>
<p>约定好之后，SpringBoot就可以根据这些目录和文件名进行扫描，排列组合也不过八种情况嘛，这些配置文件也是有优先级的，并且重复配置后，优先级低的配置文件不会覆盖优先级高的配置文件。优先级排序规则如下：</p>
<ol>
<li>项目根目录＞recourse目录</li>
<li>/config目录＞不带/config目录</li>
<li>application.properties&gt;application.yml</li>
</ol>
<p>耐人寻味的是，我们平常最常用的就是recourse目录下的application.yml，嗯……最低优先级。</p>
<p>properties文件相信大家在开发中都使用过，最常用的就是log4j和数据库信息的配置，这里我们就不再赘述了，需要讲解的是yml文件，这个文件看起来和xml有点关系，盲猜下一代配置文件叫zml文件，下面就来讲解yml文件究竟怎么用。</p>
<h3 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h3><p>YML相较于XML更加轻盈，来看一个例子</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">server.host</span>=<span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>三种方式对比后，高下立判。YML使用缩进来表示层级，相较于XML使用标签来表示层级显然更加轻盈，你看这区别像不像Java用大括号界定代码块和Python用缩进界定代码块？哦对，还有lisp圆括号，代码最后一页全都是))))))))))))))))))))))))))))))。相比较properties文件来说分层也更为明显，可读性显然比properties更加优秀，语法上反而和properties一样轻量。</p>
<p>yml的基本语法规则如下：</p>
<ol>
<li>使用缩进表示层级关系</li>
<li>不允许使用tab缩进，只能使用空格（IDE都有自动转换，放心tab）</li>
<li>缩进空格不重要，只要同层级的保持空格数量相同即可，也就是说一个空格就可以表示层级</li>
<li>大小写敏感</li>
<li>基本语法为：key:(空格)value，空格千万必要忘记！</li>
</ol>
<p>yml的value有以下写法：</p>
<ol>
<li><p>字面量：包括字符串、数字、布尔值。字符串默认不需要双引号。</p>
</li>
<li><p>键值对：可以用来表示Map和对象。例如表示server有两个有两种写法：</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="string">&#123;port:</span> <span class="number">8080</span><span class="string">,context:</span> <span class="string">hello&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组：嗯……就数组呗。</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> <span class="string">[pig,cat,dog]</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>这三种数据结构可以任意组合，无限套娃。下面来演示怎么将配置文件读取到Java中。</p>
<h3 id="读取配置文件到Java"><a href="#读取配置文件到Java" class="headerlink" title="读取配置文件到Java"></a>读取配置文件到Java</h3><p>先创建一个类——Cat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Cat&gt; friends;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略一堆getter和setter方法。</span></span><br><span class="line">    <span class="comment">//可以按alt+insert自行插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个类——Host。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编辑application.yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat:</span><br><span class="line">  name: 蓝莓</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">  host:</span><br><span class="line">    name: 周某某</span><br><span class="line">  toys:</span><br><span class="line">    - 毛球</span><br><span class="line">    - 逗猫棒</span><br><span class="line">    - 猫薄荷</span><br><span class="line">    - 周某某的头发</span><br><span class="line">  friends:</span><br><span class="line">    mary: <span class="string">"mary的主人"</span></span><br></pre></td></tr></table></figure>

<p>代码写好了，SpringBoot问你，Cat类是哪个配置文件负责配置的？你说就那个cat:开始的呗，SpringBoot又说了，别的包也有一个Cat类（假装有），我不知道注入哪一个Cat，要不你给我打个注解？好让我知道哪个Cat需要我管理，还有这个Cat是哪段配置文件配置的。</p>
<p>于是拿着SpringBoot给我们的两个注解，@ConfigurationProperties和@Component，放在了Cat的头上，Cat变成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以开始运行了！</p>
<p>还是用我们的HelloWorld类测试运行（也可以使用测试类进行测试。）</p>
<p>编辑HelloWorld类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么这样写可以看我的另一篇博客，白话Spring（一）</span></span><br><span class="line">    <span class="comment">//如果Bean有构造函数，那么可以省略@AutoWired : If a bean has one constructor, you can omit the @Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="读取非全局配置文件到Java"><a href="#读取非全局配置文件到Java" class="headerlink" title="读取非全局配置文件到Java"></a>读取非全局配置文件到Java</h3><p>上面讲到怎么把application.yml配置文件读取到Java中，那如果我有很多配置文件呢？难道都要写进application中嘛？那全局配置文件得多臃肿，修改起来也不方便，所有我们需要将部分配置信息分离出一个单独的文件。</p>
<p>SpringBoot中提供了一个@PropertySource注解，我们先看看这个注解都有什么东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个注解提供了四个值</p>
<ol>
<li>name：名称 默认为空</li>
<li>value：字符串数组，存放需要导入的配置文件路径。</li>
<li>ignoreResourceNotFound：配置文件没找到，要不要告诉你。默认false，也就是告诉你。</li>
<li>encoding：编码方式。</li>
</ol>
<p>通过上面的四个值我们可以看出这个注解可以加载多个配置文件，现在就来实战。</p>
<p>将application.yml重命名为cat.yml，修改Cat类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:cat.yml"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刷新界面，仍旧可以读取。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="SpringBoot多环境下的配置"><a href="#SpringBoot多环境下的配置" class="headerlink" title="SpringBoot多环境下的配置"></a>SpringBoot多环境下的配置</h3><p>上面我说到SpringBoot和我们约定好了一起把全局配置写到名为application文件中，我也提到了可以使用别的名字。那么什么时候我们需要使用别的名字呢？也就是SpringBoot运行环境不同的时候，我们需要不同的配置文件来配置SpringBoot，比如开发环境通常端口号是8080、生产环境端口号看老大心情。我们总不能每次换一个环境就把全局配置文件进行修改吧？估计改个几次配置文件就面目全非，找不到头尾。SpringBoot也不是那么死板的只读取application文件，多一个字少一个字都不行。</p>
<p>SpringBoot允许我们添加多个命名为application-{环境名}.yml的application配置文件。</p>
<p>例如：开发环境可以命名为：application-dev.yml或者application-dev.properties；生产环境可以命名为：application-proc.yml；测试环境可以命名为：application-test.yml</p>
<p>我们先创建上面三个不同环境下的application配置文件，分别给这三个配置文件写上：</p>
<p>application-dev.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>application-proc.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7777</span></span><br></pre></td></tr></table></figure>

<p>application-test.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>对了，还有不带后缀的配置文件application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行，SpringBoot会使用不带后缀的配置文件来配置SpringBoot。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629115552251.png" alt="image-20200629115552251"></p>
<p>可以看到端口号是application.yml中所配置的端口号。</p>
<p>怎么告诉SpringBoot本次运行需要使用哪个配置文件呢？有以下几种方式：</p>
<ol>
<li><p>修改默认配置文件：</p>
<p> 在application.yml文件中添加</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p> 这里指定了使用后缀名为dev的配置文件，运行后结果：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629120126819.png" alt="image-20200629120126819"></p>
</li>
</ol>
<pre><code>也就是SpringBoot会先去application.yml中看spring.profiles.active是否配置了另一个全局配置文件，如果配置了，就只使用相应后缀的配置文件。</code></pre><ol start="2">
<li><p>命令行模式：</p>
<p> 运行时直接加在运行jar包命令的后面 –spring.profiles.active=proc，这种方式牵扯到SpringBoot的打包和运行，不过我们在IDEA中也可以使用增加选项的方式来测试。</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629121313373.png" alt="image-20200629121313373"></p>
<p> 在配置环境中添加–spring.profiles.active=proc（意思为生产环境）</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629121913696.png" alt="image-20200629121913696"></p>
<p> 运行之后结果：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122015786.png" alt="image-20200629122015786"></p>
<p> 等等？我们在application.yml中配置了使用dev后缀的配置文件，命令行配置了proc后缀的配置文件，然而现在SpringBoot使用了proc的配置，OK，命令行方式会覆盖application中的配置。</p>
</li>
<li><p>虚拟机参数：</p>
</li>
</ol>
<pre><code>![image-20200629121313373](https://gitee.com/vanbyz/images/raw/master/img/image-20200629121313373.png)

在vm选项中添加-Dspring.profiles.active=test</code></pre><p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122816187.png" alt="image-20200629122816187"></p>
<p>运行之后：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122015786.png" alt="image-20200629122015786"></p>
<p>嗯？怎么还是proc的端口？命令行选项没有删除，也就是命令行优先级高于虚拟机配置，把命令行选项删除，再次运行。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629123135251.png" alt="image-20200629123135251"></p>
<p>这个就是test的端口号了，但是别忘了application.yml中的配置文件从来都没有删除过spring.profiles.active=dev这个配置项。</p>
<p>所以这三种配置的优先级是：命令行选项 &gt; 虚拟机选项 &gt; application中配置</p>
<h2 id="SpringBoot注册组件"><a href="#SpringBoot注册组件" class="headerlink" title="SpringBoot注册组件"></a>SpringBoot注册组件</h2><p>SpringBoot虽然可以使用@ImportRecourse注解导入Spring的xml配置文件（也就是创建Bean），但是SpringBoot不推荐这种办法，而是使用配置类来添加组件。</p>
<p>首先需要告诉SpringBoot这是一个配置类也就是前面讲过的@Configuration注解，SpringBoot会在扫描的时候将这个配置类添加到自己的小本本里。SpringBoot得知这是个配置类之后，你需要告诉它这个配置类是做什么的，Spring提供了一个注解@Bean，这个注解标注在一个方法上，它会将标注方法的返回值注册进容器。</p>
<p>来看一个例子：</p>
<p>根包目录下创建一个config包，并创建一个ConfigDemo类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//标注为配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Host <span class="title">host</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值类型是要注册的组件类，方法名是该组件在SpringBoot中的id</span></span><br><span class="line">        System.out.println(<span class="string">"创建Host成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Host(<span class="string">"小王"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再魔改一下我们的HelloWorld类（controller包中的，曾经的HelloWorld成为了我们的测试类……）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入组件</span></span><br><span class="line">    <span class="keyword">final</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后结果如下：</p>
<p>控制台：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629101604813.png" alt="image-20200629101604813"></p>
<p>浏览器：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629101623161.png" alt="image-20200629101623161"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于写完了……不算图一共五千字（废话有三千字），不知道有没有人能耐心看完……</p>
<p>先来总结下知识点：</p>
<ol>
<li>SpringBoot是什么？</li>
<li>HelloWorld怎么写？</li>
<li>如何通过Spring向导创建SpringBoot项目？</li>
<li>YML的基本语法以及怎么解析YML到Java？</li>
<li>全局配置文件的优先级</li>
<li>解析非全局配置文件到Java</li>
<li>SpringBoot读取不同环境下的全局配置文件的三种方式及优先级</li>
<li>通过配置类的方式注册组件到SpringBoot</li>
</ol>
<p>如果你看着这八条能够想起来步骤，那么这篇博客已经完成了它的使命，有任何不解请联系我，有问必答。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（二）：自动配置原理</title>
    <url>/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>INTRO:</strong>  上一篇博客讲解了SpringBoot的入门知识，了解到SpringBoot的精髓就是自动配置，自动配置的简便让SpringBoot在JavaEE领域大杀四方，学习SpringBoot自动配置的原理让我们知其所以然，博主写这篇博客就是为了让大家了解SpringBoot自动配置的原理。</p>
<a id="more"></a>

<h2 id="上文回顾"><a href="#上文回顾" class="headerlink" title="上文回顾"></a>上文回顾</h2><ol>
<li><p>SpringBoot是一个用于快速构建Spring应用的框架</p>
</li>
<li><p>创建HelloWorld步骤如下：</p>
<p> 新建maven项目；在pom.xml文件添加spring-boot-starter-parent父项目、添加spring-boot-starter核心场景启动器、添加spring-boot-starter-web场景启动器；创建controller.HelloWorld类；使用@RestController注解标注HelloWorld；使用@RequestMapping标注helloWorld()方法；在浏览器访问localhost:8080/helloWorld。</p>
</li>
<li><p>略</p>
</li>
<li><p>YML语法简单来说就是区分大小写的键值对key:(空格)value，数组使用（空格）-（空格）表示；解析YML到Java可以使用@ConfigurationProperties(“前缀”)，即可自动注入。</p>
</li>
<li><p>全局配置文件的优先级规则如下：/config比不带/config的高；项目根目录比classpath目录高；properties比yml高。</p>
</li>
<li><p>非全局文件导入需要我们使用@PropertySource(“配置文件路径+文件名”)来引入配置文件</p>
</li>
<li><p>给不同环境所使用的配置文件加-后缀，可以使用的方式及其配优先级为命令行参数-&gt;虚拟机参数-&gt;配置文件</p>
</li>
<li><p>SpringBoot使用配置类取代了applicationContext.xml文件，使用@Configuration注解和@Bean注解来完成组件的注册。</p>
</li>
</ol>
<p>上一篇博客简单的对SpringBoot进行了入门讲解，从上篇博客中，我们了解到SpringBoot在开发过程中有多方便。但是开发过程中的写业务逻辑又和Spring非常相似，这就保证了我们学习SpringBoot的成本大大降低。那么SpringBoot靠什么保证了这些优点呢？SpringBoot的自动配置是怎么实现呢？本文会通过查看源代码的方式来讲解SpringBoot的工作原理，在讲解的过程中，博主还会说一下自己是怎么阅读源代码的（仅供参考……欢迎大家介绍自己方法）。</p>
<h2 id="博主是怎么阅读源码的"><a href="#博主是怎么阅读源码的" class="headerlink" title="博主是怎么阅读源码的"></a>博主是怎么阅读源码的</h2><p>首先简单讲一下我是怎么阅读源码的，我阅读源码分为几个步骤：</p>
<ol>
<li>先找线头、也就是从哪里开始看。</li>
<li>分块查看、查看核心方法的作用。按照调用方-&gt;参数-&gt;返回值的顺序查看，首要任务是弄明白这个核心方法做了什么事情。这一步有一个不算技巧的技巧，值得我们研究的源码都是优秀的源码，那么命名必定是规范明确的，我们可以通过方法名去推断这个方法的实际作用。对于核心方法调用的非核心方法，我们只需要通过方法名判断这个被调用的方法做了什么就可以了，不需要点进去查看。</li>
<li>机制总结、查看过核心代码的作用之后，我们需要看这个核心代码的机制是什么，也就是怎么实现这个功能的？实现这个功能分了几步？每步的顺序是什么？用了哪些设计模式？</li>
<li>理清原由、这一步就比较深入了，这一步需要我们认真思考代码作者在写这段代码的时候是怎么想的，为什么作者要这样写？这样设计有什么好处？还能否继续改进？</li>
</ol>
<p>在本文中，我们只需要看到第二步，更细致的解读我大概会在以后单独做一个系列，现在只需要了解SpringBoot的基本原理就行了。</p>
<h2 id="SpringBoot自动配置源码解读"><a href="#SpringBoot自动配置源码解读" class="headerlink" title="SpringBoot自动配置源码解读"></a>SpringBoot自动配置源码解读</h2><h3 id="找线头"><a href="#找线头" class="headerlink" title="找线头"></a>找线头</h3><p>按照上面分享的阅读源码的方式，我们要先找到线头，线头当然是我们的main方法，那这个main方法有什么特殊的呢？没错，就是头上顶着的那个@SpringBootApplication注解，点进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>嗯……上一篇博客已经讲过这个了，这里再回顾下，@SpringBootConfiguration的底层是Spring中的@Configuration，告诉SpringBoot这是一个配置类。（你看，这不学Spring的话，SpringBoot源码就难搞）</p>
<p>看下一个注解，光看名字就很重点@EnableAutoConfiguration，翻译下叫做开启自动配置。嘿！这不是今天这个博客的主要研究对象吗？线头找到了，下一步！</p>
<h3 id="粗看代码"><a href="#粗看代码" class="headerlink" title="粗看代码"></a>粗看代码</h3><p>点进@EnableAutoConfiguration注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<p>又是两个注解的组合，我们一个一个的看，先看@AutoConfigurationPackage（自动配置包）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Import这个注解要说说，这个注解也是Spring中的注解，意思就是导入配置类。</p>
<p>查看这个Registrar类，发现它是一个静态内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">       Registrar() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">           AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个方法registerBeanDefinitions（注册Bean）、determineImports（确认导入）。</p>
<p>看registerBeanDefinitions方法调用了一个注册方法，通过方法名我们可以推断是注册Bean到容器中。后面还创建了一个AutoConfigurationPackages对象，并且将这个对象中的存放的包名作为值传了出去。这个包名是谁的包名呢？看PackageImport(metadata)，这里传入了一个注解元数据信息，我们在这一行打一个断点，然后debug的方式运行。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629175634050.png" alt="image-20200629175634050"></p>
<p>没错，这个元数据表明这个注解在SpringBootDemo类上，通过这个元数据信息，PackageImports计算出basePackages，然后通过for循环将这个包下所有的子包都添加进packageNames中。ok，绕了一大圈原来SpringBoot通过@SpringBootApplication -&gt; @EnableAutoConfiguration -&gt; @AutoConfigurationPackage -&gt; @Import注解的元数据知道主配置类（被@SpringBootApplication标注的类）所在的包，然后将主配置类所在包的所有子包都放到packageNames中存储起来。也就是SpringBoot注册组件时，需要扫描的包。类比Spring的配置文件，它可以取代以下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"org.exmples.xxx"</span>&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>虽然看着麻烦，其实SpringBoot都私下帮你做好了。</p>
<p>再来看@EnableAutoConfiguration的另一个注解：@Import({AutoConfigurationImportSelector.class})</p>
<p>Import注解之前说过了，它用来导入配置类，那么我们看看AutoConfigurationImportSelector（自动配置导入选择器）类。</p>
<p>这个类里面的东西比较多，我们主要关注的内容是selectImports()方法，其他所有的都是为这个方法做辅助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">           <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry</span><br><span class="line">               =<span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">           <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>selectImports主要调用了getAutoConfigurationEntry()方法根据注解元数据获取AutoConfigurationEntry对象，然后将对象中存储的配置返回。</p>
<p>首先我们来查看 AutoConfigurationEntry 的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; configurations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; exclusions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AutoConfigurationEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurations = Collections.emptyList();</span><br><span class="line">        <span class="keyword">this</span>.exclusions = Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoConfigurationEntry(Collection&lt;String&gt; configurations, Collection&lt;String&gt; exclusions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configurations = <span class="keyword">new</span> ArrayList(configurations);</span><br><span class="line">        <span class="keyword">this</span>.exclusions = <span class="keyword">new</span> HashSet(exclusions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getExclusions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.exclusions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码我们可以看出AutoConfigurationEntry中按照List的结构存放configuration。这些配置如何存放进AutoConfigurationEntry中的呢？通过代码可以看出实例对象都是找getAutoConfigurationEntry()方法拿的，我们去问它好咯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry </span><br><span class="line">    getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//下面这一行很重要</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            <span class="comment">//下面这一行也很重要</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑还是比较简单清晰的，首先创建两个集合框架，通过给getCandidateConfigurations（获取候选配置）方法传入注解元数据信息和属性信息来获取configurations，随后调用removeDuplicates()方法进行去重处理，这时出现了一个exclusions，这里存放不需要自动装配的组件，configurations将这些组件移除（此时CandidateConfigurations才真正变为configurations），又经过getConfigurationClassFilter过滤器的过滤之后才将其返回给selectImports方法。很明显在这一段代码中，需要我们注意的两个方法是getCandidateConfigurations()和filter()。</p>
<p>先来看getCandidateConfigurations()，它负责收集所有的候选组件，然后这些组件经过去重、去排除、经过滤器后才被注册。</p>
<p>点进去后发现关键代码就一句</p>
<p>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</p>
<p>果然还是绕到Spring中来了，来都来了，看看呗。loadFactoryNames调用了loadSpringFactories方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过类加载器读取了下的META-INF/spring.factories，我们找找这个在哪。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629224844085.png" alt="image-20200629224844085"></p>
<p>看第二个spring-boot-autoconfigure点开，为什么直奔第二个，男人的直觉，哼哼！</p>
<p>再点开META-INF/spring.factories文件，可以看到一堆的全限定类名，SpringBoot会将全限定类名全部注册到容器中。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629225232015.png" alt="image-20200629225232015"></p>
<p>出现在这里的全限定类名都将加入到SpringBoot容器中，只有加入到容器中的类才能被Springboot进行配置。</p>
<p>没错，云里雾里讲了那么久，自动配置的原理才刚刚开始。讲的有点乱，所以到这里先捋一捋。</p>
<p>SpringBoot会自动配置一些组件（比如我们的server组件的server.port），SpringBoot有哪些组件会自动配置，SpringBoot又是怎么配置这些组件呢？首先这些组件需要加载进SpringBoot中，这样才能被SpringBoot管理。使用@SpringBootApplication中的@EnableAutoConfigration会读取org.springframe.boot:spring-boot-autoconfigure依赖的META-INF/spring.factories文件的一系列全限定类名，SpringBoot通过这些全限定类名加载进容器中，那么SpringBoot就能通过反射+全限定类名创建自动配置组件的实例对象。</p>
<p>讲完SpringBoot怎么自动将自动配置组件注册进容器中后，再学习这些自动配置组件是怎么自动配置的。</p>
<p>我们选择一个常用的数据源配置项所属的自动配置类来分析</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按住ctrl点击这个类，查看这个类的源代码，发现这个类有一大堆注解，我们来一个一个分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">EmbeddedDatabaseType</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= &#123;<span class="string">"io.r2dbc.spi.ConnectionFactory"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DataSourceProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;DataSourcePoolMetadataProvidersConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">DataSourceInitializationConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先是@Configuration注解，这个我们都不陌生，表示被标注的类是一个配置类。</p>
<p>其次是@ConditionalOnClass注解，这个注解是Spring中的注解，意思就是如果有DataSource和EmbeddedDatabaseType才会创建这个Bean。你可以左键单击这两个类，发现找不到EmbeddedDatabaseType，因为你没有添加DataSource的依赖，也就是说SpringBoot不会帮你自动配置DataSource。</p>
<p>然后是@ConditionalOnMissingBean注解，看名字是只有io.r2dbc.spi.ConnectionFactory这个Bean不存在的时候才会创建Bean，这是DataSource，至于这个Bean是什么，需要我们学习相关的启动器了。</p>
<p>下一个是@EnableConfigurationProperties注解，这个注解看起来很熟悉，像是我们之前用过的@ConfigurationProperties注解，不知道大家还有没有印象，@ConfigurationProperties注解用于配置类读取配置文件信息。再看@EnableConfigurationProperties注解中导入的类文件DataSourceProperties.class，追踪进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.datasource"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> generateUniqueName = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String jndiName;</span><br><span class="line">    <span class="keyword">private</span> DataSourceInitializationMode initializationMode;</span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; schema;</span><br><span class="line">    <span class="keyword">private</span> String schemaUsername;</span><br><span class="line">    <span class="keyword">private</span> String schemaPassword;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data;</span><br><span class="line">    <span class="keyword">private</span> String dataUsername;</span><br><span class="line">    <span class="keyword">private</span> String dataPassword;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> continueOnError;</span><br><span class="line">    <span class="keyword">private</span> String separator;</span><br><span class="line">    <span class="keyword">private</span> Charset sqlScriptEncoding;</span><br><span class="line">    <span class="keyword">private</span> EmbeddedDatabaseConnection embeddedDatabaseConnection;</span><br><span class="line">    <span class="keyword">private</span> DataSourceProperties.Xa xa;</span><br><span class="line">    <span class="keyword">private</span> String uniqueName;</span><br><span class="line">    <span class="comment">//省略一堆方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这些属性和头上的@ConfigurationProperties注解，恍然大悟，这是来到DataSource配置类了，这个前缀表示如果我们像配置数据源信息就要使用层级为spring.datasource开始的配置（对这块有疑问的可以回头看看上一篇博客，或者根据博客底部的联系方式联系我）。这么看来@EnableConfigurationProperties这个注解就是来给皇军带路的。</p>
<p>但是这个DataSourceProperties配置类怎么用呢？。接下来就是见证奇迹的时刻，我们来看DataSourceAutoConfiguration类中最后一个注解@Import()，这个注解之前说过了，就是给这个类导入组件的，这里导入了两个类——数据源池元数据提供程序配置.class和数据源初始化配置.class，我们先看</p>
<p>DataSourcePoolMetadataProvidersConfiguration.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourcePoolMetadataProvidersConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataSourcePoolMetadataProvidersConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;BasicDataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">CommonsDbcp2PoolDataSourceMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        CommonsDbcp2PoolDataSourceMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意这个注解</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">commonsDbcp2PoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                BasicDataSource dbcpDataSource = (BasicDataSource)DataSourceUnwrapper.unwrap(dataSource, BasicDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> dbcpDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> CommonsDbcp2DataSourcePoolMetadata(dbcpDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;HikariDataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">HikariPoolDataSourceMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        HikariPoolDataSourceMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意注意</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">hikariPoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                HikariDataSource hikariDataSource = (HikariDataSource)DataSourceUnwrapper.unwrap(dataSource, HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> hikariDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> HikariDataSourcePoolMetadata(hikariDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;DataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">TomcatDataSourcePoolMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        TomcatDataSourcePoolMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意注意</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">tomcatPoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                DataSource tomcatDataSource = (DataSource)DataSourceUnwrapper.unwrap(dataSource, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> tomcatDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> TomcatDataSourcePoolMetadata(tomcatDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得@Bean这个注解吗？这个注解上一篇博客中讲过，用于给Springboot中注册组件。这三个注解根据存在不同的类可以注册不同的datasource到SpringBoot容器中，然后datasource这个依赖就可以注入DAO层框架（例如Mybatis）了。</p>
<p>根据这个注解，我们就知道，SpringBoot自动配置支持的三个datasources pool是：</p>
<ol>
<li>tomcatPool</li>
<li>hikariPool(号称最快的数据源池，我没试过，有空玩玩)</li>
<li>dbcp2</li>
</ol>
<p>上面的知识并不是我们的目的，只是为了展示我们阅读源码的目的，你看我们通过阅读源码知道了为什么自动配置只支持这三个数据源池，而不是简单通过官方文档中的知其然而不知其所以然。</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>限于篇幅问题（我太懒……），这篇博客不再详细进行源码解读的第三步第四步了。</p>
<p>接上半场的总结，SpringBoot通过一系列的注解找到spring-boot-autoconfigure依赖包下的META-DATA/spring.factories文件，这个文件中含有很多自动配置类的全限定类名，SpringBoot通过这些全限定类名，将这些自动配置类记录下来（还没创建Bean）。通过这些类上的@Conditional系列注解来判断是否创建这个自动配置类的Bean，经过重重筛选，符合当前开发环境的自动配置类会通过@EnableConfigurationProperties注解设置配置类，而这个配置类的配置信息通过设置前缀名来读取全局配置文件中对应的配置信息。自动配置类又会通过@Bean注解将配置类中的配置信息利用起来，返回一个我们可以使用的Bean（例如配置好的datasource）。其他组件可以使用依赖注入的方式调用这个配置好的Bean。</p>
<p>简单来说，SpringBoot的自动配置分为两部分:</p>
<ol>
<li>注册自动配置类，这些类命名为xxxAutoConfiguration。这一部分又可以细分为下面步骤：<ul>
<li>@SpringApplication -&gt; @EnableAutoConfiguration </li>
<li>设置基础包，包为@SpingApplication标注类所在的包</li>
<li>利用iSpringFactoriesLoader读取META-DATA/spring.factories文件，将里面的url记录进SpringBoot。</li>
</ul>
</li>
<li>自动配置<ul>
<li>根据@Conditional注解筛选需要注册为Bean的自动配置类</li>
<li>自动配置类通过@EnableConfigurationProperties注解让xxxProperties配置类读取配置文件</li>
<li>自动配置类利用配置类中的信息初始化组件，并通过@Bean注解将组件的注册为Bean。</li>
</ul>
</li>
</ol>
<p>面试中这样说……大概可以吧？</p>
<p>这一章理论知识比较多，请大家把这条线捋一下，我只是简单的把自动配置这条路线走了一遍，有精力的同学可以再细致研究这些功能的实现机制。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（一）：Redis基础入门</title>
    <url>/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> 在实际开发过程中，我们会经常用到Redis，作为一个高速缓存数据库，我们该从哪里开始学习呢？本文参考Redis文档作为大纲编写，从这篇博客开始开辟Redis这个高速公路。</p>
<a id="more"></a>

<h2 id="Redis是个啥？"><a href="#Redis是个啥？" class="headerlink" title="Redis是个啥？"></a>Redis是个啥？</h2><p>Redis本质上是一个以key-value存储的数据库。那么key-value数据库可太多了，我们为什么都用redis呢？</p>
<p>因为Redis是一个内存数据库，并且支持数据持久化，这里解释一下数据持久化。</p>
<p><strong>数据持久化：</strong>其实这个词学过数据库的都会知道什么意思，但是照顾下初学者（顺便凑凑字数）还是说一说。我们以前的程序都是在内存玩玩，包括我们第一个程序HelloWorld也好，各种排序算法也好，这些东西都是在内存中的。只要我们关闭程序或者计算机断电，所有的东西就都没了（参考老版本的Word文档）。那么我们的数据存在哪里才不会受到这种限制呢？那当然是硬盘啦！像Mysql、Oracle这种就是将数据存进硬盘中，那么问题来了，硬盘它读写速度慢啊！访问量一上去，读写速度直接成为系统瓶颈。于是有大佬想出一个办法，我把常用数据存在内存中不就行了吗？Redis就在这种背景下横空出世。</p>
<p><strong>Redis的优势</strong>： 刚才讲到Redis的出生背景，可能有些人开始疑惑了，这不是开倒车吗？刚说完数据持久化，你就把数据放到内存了。万一服务器断电，数据不就没了？大佬毕竟是大佬，只要大佬高可用做的好，灾难就追不上大佬。Redis支持主从模式的数据备份，主挂了，我还有从呢！Redis支持数据持久化，可以把数据存进硬盘中，等到重启的时候再拿出来用。（大胆猜测下，向Redis写入数据时，Redis需要做三件事：存数据到主节点内存；同步数据到从节点；同步数据到硬盘。我们在学习过程中再看到底是不是这样。）</p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>入门第一步当然是先安装主角啦！进入<a href="https://redis.io/" target="_blank" rel="noopener">Redis官网</a>寻找Download关键字，看到Download相关的点进去就完事了。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709100113889.png" alt="image-20200709100113889"></p>
<p>点击一下，直接就下载了。默认时linux版本的gz文件，如果你想下载windows版本的可以在这里<a href="https://github.com/tporadowski/redis/releases" target="_blank" rel="noopener">gayhub</a>下载安装。我这里有一台Linux服务器，我就使用linux版本了。希望大家有条件的可以创建虚拟机来操作Linux。</p>
<p>偷偷告诉大家一个小技巧，win10自带的Powershell可以直接使用ssh/scp来链接服务器或者上传文件。</p>
<p>我这里使用的ssh工具是Termius，好用倒是没多好用，就是界面美观。scp就用Powershell了。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709102039501.png" alt="image-20200709102039501"></p>
<p>不得不说微软现在越来越开放了，像VS Code、Powershell等都支持跨平台了，我的青春结束了。</p>
<p>来到服务器，在/root目录运行解压redis安装包</p>
<blockquote>
<p>tar -zxvf  redis-6.0.5.tar.gz</p>
</blockquote>
<p>进入目录并且编译</p>
<blockquote>
<p>cd redis-6.0.5/ &amp;&amp; make</p>
</blockquote>
<p>如果编译期间报错，那么就是你的gcc版本出现问题，两种解决方案：升级gcc；使用更低的Redis版本；</p>
<p>*注意！生产环境中不可擅自升级gcc，凡事先问运维可不可以升级！</p>
<p>我这里选择升级gcc，按顺序运行这些命令，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y cpp</span><br><span class="line">yum install -y binutils</span><br><span class="line">yum install -y glibc</span><br><span class="line">yum install -y glibc-kernheaders</span><br><span class="line">yum install -y glibc-common</span><br><span class="line">yum install -y glibc-devel</span><br><span class="line">yum install -y gcc</span><br><span class="line">yum install -y make</span><br><span class="line"></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"></span><br><span class="line">echo "source /opt/rh/devtoolset-9/enable" &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<blockquote>
<p>src/redis-server</p>
</blockquote>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709111549533.png" alt="image-20200709111549533"></p>
<p>出现这个就说明Redis的server端启动起来了，可以通过redis内置的一个客户端与服务端进行交互。</p>
<p>因为这个被占用了，另开一个ssh链接。</p>
<p>运行命令</p>
<blockquote>
<p>src/redis-cli</p>
</blockquote>
<p>这个时候进入了redis命令行模式，我们输入set的时候，redis会自动给我们提示</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709112032802.png" alt="image-20200709112032802"></p>
<p>小声bb：Mysql赶紧跟人家学学！</p>
<p>然后，在命令行输入</p>
<blockquote>
<p>set hello world</p>
</blockquote>
<p>输出OK，表示我们已经完成了key-value的添加</p>
<p>输入</p>
<blockquote>
<p>get hello</p>
</blockquote>
<p>输出 “world”</p>
<p>至此一个简单的测试用例就完成了。如果你觉得安装redis还需要使用虚拟机有点麻烦，并且你不想redis占用资源，那么你可以通过<a href="https://try.redis.io/" target="_blank" rel="noopener">在线Redis</a>，来学习Redis。</p>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis的配置文件是位于安装目录下的<strong>redis.conf</strong>文件，可以通过Config来查看或者配置Redis。</p>
<p>格式为：</p>
<blockquote>
<p>CONFIG GET CONFIG_NAME</p>
</blockquote>
<p>例如我们可以输入 CONFIG GET * 来查看所有的配置</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709125521604.png" alt="image-20200709125521604"></p>
<p>从这里们可以看出配置文件的结构是两行为一个配置，奇数行是配置名，这个奇数行下面的偶数行是该配置项的值。</p>
<p>也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;配置名xxx&quot;</span><br><span class="line">2) &quot;xxx的值&quot;</span><br></pre></td></tr></table></figure>

<p>我们会在后面的知识讲解这些配置项的含义。</p>
<p>先使用CONFIG GET PORT查看redis日志的等级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET loglevel</span><br><span class="line">&quot;loglevel&quot;</span><br><span class="line">&quot;notice&quot;</span><br></pre></td></tr></table></figure>

<p>使用CONFIG SET CONFIG_NAME CONFIG_VALUE 的格式可以设置配置项的值，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG SET loglevel warning</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>再查看的时候结果就变了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET loglevel</span><br><span class="line">&quot;loglevel&quot;</span><br><span class="line">&quot;warning&quot;</span><br></pre></td></tr></table></figure>

<p>题外话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: since Redis is pretty fast an outside user can try up to 150k passwords per second against a good box. This means that you should use a very strong password otherwise it will be very easy to break.</span><br><span class="line">因为redis速度太快，所以暴力破解密码也很快，如果你的redis地址暴露，数据安全岌岌可危。</span><br></pre></td></tr></table></figure>

<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>Redis支持五种基本的数据结构：</p>
<p><strong>String：</strong>这是Redis中最基本的元素，它不仅仅可以存储我们日常中的字符串，它还能存储一些音乐、图片，甚至序列化之后的Java对象(你想到了什么？)，一个String最多可以存储<strong>512MB</strong>的内容。</p>
<blockquote>
<p>SET url “blooog.top”</p>
<p>OK</p>
<p>GET url</p>
<p>“blooog.top”</p>
</blockquote>
<p><strong>Hash：</strong> Redis中的Hash是一系列键值对的集合，类似于Java中的Map，Hash本质上是String类型的field和String类型的value的映射表，一个Hash映射表可以存储2<sup>32</sup> -1个键值对。</p>
<p>我们在Redis命令行敲上HMSET 出现一串提示：</p>
<blockquote>
<p>HMSET key field value [field value ……]</p>
</blockquote>
<p>根据这个结构我们输入一个Hash</p>
<blockquote>
<p>HMSET user:admin name zhouxx url blooog.top post redis</p>
</blockquote>
<p>然后使用命令</p>
<blockquote>
<p>HGETALL user:admin</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;zhouxx&quot;</span><br><span class="line">3) &quot;url&quot;</span><br><span class="line">4) &quot;blooog.top&quot;</span><br><span class="line">5) &quot;post&quot;</span><br><span class="line">6) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p><strong>List：</strong> 类似于数组，里面可以存储 2<sup>32</sup> -1个String类型的元素，使用LPUSH命令可以进行存储，语法也比较简单，直接把要存进去的元素写在后面就行了。</p>
<p>例如：</p>
<blockquote>
<p>LPUSH exlist zhouxx blooog.top redis</p>
</blockquote>
<p>取出元素可以使用LRANGE命令</p>
<blockquote>
<p>LRANGE exlist 0 5</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;zhouxx&quot;</span><br></pre></td></tr></table></figure>

<p>注意，List中的顺序和们输入的顺序是相反的，为什么会这样呢？因为我们使用的是LPUSH，也就是按照输入的顺序从List左边插入。</p>
<p><strong>Set：</strong> 类似Java中的Set，你看着数据结构都是相通的，数据结构一定要学好，有机会开一个数据结构的博客。Set通过哈希表实现，所以它的添加、删除、查找的时间复杂的都是O(1)。</p>
<p>使用SADD KEY ELE添加元素，例如：</p>
<blockquote>
<p>SADD exset zhouxx</p>
<p>SADD exset blooog.top</p>
<p>SADD exset redis</p>
</blockquote>
<p>使用SMAMERS zhouxx命令查看集合中的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;zhouxx&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>同样的，Set中也可以存放2<sup>32</sup> -1个String类型的元素。</p>
<p>注意：Set中仅能存放不同的元素，第二次插入的相同元素会无效。</p>
<p><strong>Zset：</strong> 有序集合，Zset和Set相似，都不允许插入相同的元素，不同的是Zset中每个元素都有一个Score用来代表权值，Redis通过Score来进行排序。默认为正序，并且Score可以重复。</p>
<p>使用 ZADD KEY SCORE ELE添加元素，例如：</p>
<blockquote>
<p>ZADD exzset 12.12 zhouxx</p>
<p>ZADD exzset 11.11 blooog.top</p>
<p>ZADD exzset 6.18 redis</p>
</blockquote>
<p>使用ZRANGEBYSCORE KEY START END命令读取SCORE区间内的元素</p>
<blockquote>
<p>ZRANGEBYSCORE  exzset 6.18 12.12</p>
</blockquote>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;zhouxx&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出这个范围要求是双向闭区间。</p>
<h2 id="Redis和它的二百命令"><a href="#Redis和它的二百命令" class="headerlink" title="Redis和它的二百命令"></a>Redis和它的二百命令</h2><p>回顾全文，可以看出redis中的功能还是很强大的（并没有），数据结构还是很复杂的（并没有）。</p>
<p>命令还是很多的（这个是真的有！），据官网上说，Redis有二百多条命令。</p>
<p>Redis官方把根据命令负责的模块，将命令分为多个命令集，有了分类再掌握命令就方便了。官网也提供了快速查询的通道。</p>
<p>英文：<a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令查询</a></p>
<p>中文：<a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令查询</a></p>
<p>中文版的翻译不是很全，但是一些经常用的命令都做了翻译。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐的SpringMVC（一）：前后端分离下的SpringMVC</title>
    <url>/%E5%BF%AB%E4%B9%90%E7%9A%84SpringMVC%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8B%E7%9A%84SpringMVC/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> SpringMVC主要负责MVC模式的实现。SpringMVC近几年来已经逐渐取代Struts2的地位，当然现在是SpringBoot大行其道，那么为什么还要学习SpringMVC呢？因为SpringBoot是Spring的封装，而SpringMVC又是Spring的组件，所以不学习SpringMVC就无法掌握SpringBoot的web部分。</p>
<a id="more"></a>

<h2 id="MVC是什么"><a href="#MVC是什么" class="headerlink" title="MVC是什么"></a>MVC是什么</h2><p>SpringMVC中最显眼的就是MVC，那么什么是MVC呢？MVC即Model、View、Controller。是不是听上去很懵逼？如果不使用MVC会怎样？胡子眉毛一把抓，直接在JSP中写上连接数据库的代码，有些同学疑惑了PHP不就是这样的嘛？Java是一个工程上的语言，虽然Java对设计模式等可能有些滥用的情况，但是这种前后端强耦合的情况Java是绝对不允许的。于是一些大佬就推广MVC模式，大佬是这样说的：任何应用程序设计都遵循MVC模式。View：视图，给用户看的；Model：模型，不同用户需要看到的不同资源；Controller：控制器，将Model和View结合。</p>
<p>MVC最常和什么技术一起使用呢？JSP（Java Server Page），当然JSP技术终将会被淘汰，但是这里使用JSP技术讲解MVC模式会更容易理解。JSP中使用JSTL标签库来标记什么地方需要插入动态数据（也就是你数据库查出来的东西），我们呈现给客户的是带有各种标签的原生界面嘛？并不是，而是经过替换标签、渲染完成的HTML，那么JSP是怎么变成HTML的呢？在SpringMVC中有一个视图解析器，它会将JSP文件拿出来，再将Model数据捏上去，合成一个HTML加到Response体中，再返回给浏览器。</p>
<p>有些新手可能会有误解，以为Model数据和JSP一起返回到浏览器，由浏览器进行渲染界面，这是错误的。还记得我们开发JSP过程中最讨厌的事情是什么嘛？JSP不能在浏览器中打开看样式！也就是说浏览器根本不知道你JSP是个啥，浏览器只认识HTML，所以JSP转换为HTML的过程是在服务器上进行的。</p>
<p>问题来了，MVC是怎么知道哪个JSP要和哪个Model数据捏在一起的呢？这就是Controller的作用啦！我们先写一个Controller实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    EmService emService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmController</span><span class="params">(EmService emService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emService = emService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"getAllem"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getAllem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView;</span><br><span class="line">        List&lt;Em&gt; ems = emService.getAllEm;</span><br><span class="line">        <span class="comment">//注意这句</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">"/WEB-INF/views/all_em.jsp"</span>);</span><br><span class="line">        <span class="comment">//注意这句</span></span><br><span class="line">        modelAndView.addProject(<span class="string">"em"</span>,ems);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个Controller实例，从实例中看出来，我们通过Service层（严格意义上来说，Service层在MVC模式中属于Model层）获得所有的Em，将Em封装进List中，通过ModelAndView对象中的addObject()方法，告诉SpringMVC这是等会你做视图解析需要用到的Model数据，解析到哪个JSP中？setViewName方法已经告诉你了，解析到/WEB-INF/views文件夹下的all_em.jsp这个JSP文件（可以配置视图解析器前后缀，这样就不用写一大串了，只需要写JSP的文件名就行了）。</p>
<p>通过这个例子我们可以基本了解SpringMVC中的MVC到底是什么了，其实就是做完型填空，答案：数据（Model）；答题卡：界面模板（View）；试卷：这个空对应哪道题（Controller）；抄答案做填空：（视图解析器）。</p>
<p>拿到答题卡和试卷之后，我们先做试卷找到答案（通过Model层获取数据，查询数据库也好，自己胡编乱造也好。），看题号找到答题卡对应的位置（通过Controller将Model和View对应起来），填好答案（视图解析器），将填好的答题卡（HTML）交给老师（浏览器）。</p>
<h2 id="前后端分离下的MVC模式"><a href="#前后端分离下的MVC模式" class="headerlink" title="前后端分离下的MVC模式"></a>前后端分离下的MVC模式</h2><p>曾经的曾经JSP还在统治世界的时候，前后端分离也就是前端写界面，后端改成JSP。耦合度那叫一个高啊。经常后端改成JSP之后，界面崩了，鼻子不是鼻子，眼睛不是眼睛。前端还在家里睡觉呢，后端一个电话喊来加班一起改界面。于是前端说：这是我的界面？后端说：嗯呢，我稍微修改了一下。前端看着嵌入的JSTL说：啥啥啥，这都是啥？后端看着CSS和JavaScript说：啥啥啥，这又是啥？前端怒了，耦合度那么高，再干两年JDK更新都得请我去开会了。后端也怒了，再干两年我都得参与HTML6的研发了。</p>
<p>后来呢？MVC模式准备分家了，前后端对话如下：</p>
<p>前端：你别管我的界面了，你把数据给我，我自己加到界面里面。</p>
<p>后端：那我给你传个Java对象，你能用啊？</p>
<p>前端：大哥，能传个字符串不。</p>
<p>后端：我想想，那我们约定一个规范好了，专门用来前后端传输数据的。</p>
<p>前端：别了，这么麻烦呢？我这边准备用JavaScript渲染数据到界面上，你就给我传个JSON格式的字符串好了。</p>
<p>后端：那你怎么知道我返回的是失败的数据还是成功的数据呢？</p>
<p>前端：还记得HTTP嘛？HTTP有什么状态码还知道不？</p>
<p>后端：那我把数据、状态码、状态信息封装起来一起交给你吧。</p>
<p>前端：OKOK！</p>
<p>于是，前后端彻底分离了。</p>
<p>说这个是为了什么呢？就是为了告诉大家现在开发更加方便，我们将一部分的工作量分给了前端，所以目测最近几年前端所需要的人才缺口爆炸。这样一想……我准备转行去前端了，不写了，大家再见！</p>
<p>我回来了，他们要三年经验……</p>
<p>这里需要大家明白一点，虽然前后端分离大行其道，但是博主认为前后端分离是MVC模式的进化版本，MVC不会过时，过时的只是JSP这种前后端高度耦合的技术。</p>
<h3 id="SpringMVC实例"><a href="#SpringMVC实例" class="headerlink" title="SpringMVC实例"></a>SpringMVC实例</h3><p>博主使用的工具是idea，经常听大家说idea创建maven不好用，经过多个版本更新之后，idea现在除了收费应该没有什么短板了。</p>
<p>下面就跟着博主一步一步进行。</p>
<p>首先创建一个Maven项目</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144026841.png" alt="image-20200711144026841"></p>
<p>给项目选一个喜欢的名字。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144305974.png" alt="image-20200711144305974"></p>
<p>选择Maven的配置文件和本地仓库。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144505757.png" alt="image-20200711144505757"></p>
<p>接下来就进入到我们的项目界面了，来看一下项目结构</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711155349934.png" alt="image-20200711155349934"></p>
<p>在web.xml中写上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring的ApplicationContext 载入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定加载外部的spring-mvc配置文件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>resources/applicationContext.xml中写上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用context命名空间，自动扫描包top.vanbyz下的类，除了Controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在DemoController中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> top.blooog.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> top.blooog.util.AjaxResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoController</span><span class="params">(DemoService demoService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.demoService = demoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult&lt;List&gt; <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AjaxResult&lt;List&gt; ajaxResult = <span class="keyword">new</span> AjaxResult&lt;&gt;();</span><br><span class="line">        ajaxResult.setCode((<span class="keyword">short</span>) <span class="number">200</span>);</span><br><span class="line">        ajaxResult.setData(demoService.demo());</span><br><span class="line">        ajaxResult.setMessage(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> ajaxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DemoService中写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"SpringMVC 你好！"</span>);</span><br><span class="line">        list.add(<span class="string">"欢迎来到我的个人博客"</span>);</span><br><span class="line">        list.add(<span class="string">"blooog.top"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后配置Tomcat。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174426765.png" alt="image-20200711174426765"></p>
<p>像我这样配置，如果出现了红色提示，就点击Fix。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174451849.png" alt="image-20200711174451849"></p>
<p>看起来像是OK了，运行Tomcat。</p>
<p>浏览器弹出了这个界面：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174609270.png" alt="image-20200711174609270"></p>
<p>嘿？怎么不输出我们设置的数据呢？原来是路径问题，在@RequestMapping注解标注了访问这个Controller方法的路径，我们重新试一下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174833487.png" alt="image-20200711174833487"></p>
<p>成功报错，也就是不认识AjaxResult这玩意，SpringMVC跟我们说：你怎么能把这玩意（AjaxResult对象）塞到响应体呢？！我干不了，你再找人吧！</p>
<p>嗯……我们给SpringMVC找一个能干这个的棒小伙吧！没错，JSON解析工具！</p>
<p>我们这里使用fastjson，这是国货之光阿里巴巴的作品，在pom文件中添加：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阿里JSON解析器 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.70&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此时需要告诉SpringMVC我们要用Fastjson组件，编辑spring-mvc.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--将最后一行的&lt;mvc:annotation-driven/&gt;修改为--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span> <span class="attr">value</span>=<span class="string">"application/json"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重新访问地址localhost:8080/hello</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711181251731.png" alt="image-20200711181251731"></p>
<p>搞定！</p>
<p>当然，fastjson并没有我们现在用的这么简单，后期有时间的话我会出一个详细一点的教程。</p>
<h3 id="前后端开发利器——PostMan"><a href="#前后端开发利器——PostMan" class="headerlink" title="前后端开发利器——PostMan"></a>前后端开发利器——PostMan</h3><p>前面使用了浏览器进行调试（因为没有界面……），博主又不会前端这些鬼东西，没有参数的时候还好说，像HelloWorld一样字符串直接显示在浏览器上。有参数的时候呢？例如我们的登录，又怎么验证呢？难道使用浏览器那个小小小小小的调试窗口进行测试嘛？</p>
<p>接下来我介绍一个开发利器给大家PostMan，邮差！这个软件是谷歌出品，用于后端接口测试，曾经提供谷歌浏览器插件，后来独立为一个软件。</p>
<p>可以通过<a href="https://www.postman.com/" target="_blank" rel="noopener">PostMan官网</a>进行下载，博主这里简单介绍用法。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711184608990.png" alt="image-20200711184608990"></p>
<p>可以看到响应模块中的body比浏览器中显示的更加清晰。</p>
<p>更多使用方法可以参考博客<a href="https://www.jianshu.com/p/97ba64888894" target="_blank" rel="noopener">Postman教程大全</a>，使用方法很简单，博主就不再啰嗦了。</p>
<h2 id="SpringMVC实例讲解"><a href="#SpringMVC实例讲解" class="headerlink" title="SpringMVC实例讲解"></a>SpringMVC实例讲解</h2><p>经过上面的实例，我们对SpringMVC也有了一些认识，首先就是我们需要进行一些配置，web.xml中配置dispatcherServlet和Mapping，这个Servlet是SpringMVC的总入口。还记得Servlet是什么嘛？往往我们一个Servlet代表一个功能，但是SpringMVC将所有请求（除了静态）都集中下来，交给dispatcherServlet，使用dispatcherServlet来执行我们的业务逻辑。dispatcherServlet具体内容的讲解我会在SpringMVC的原理中讲解。</p>
<p>我们都知道SpringMVC是Spring中的一个组件，所以我们本能的认为Spring和SpringMVC是无缝衔接的，来我们看applicationContext中的一个配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用context命名空间，自动扫描包top.vanbyz下的类，除了Controller --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在applicationContext配置文件中，通过&lt;context:exclude-filter&gt;标签我们让Spring不要扫描controller，而在spring-mvc.xml中，我们又重新扫描Controller。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置mvc的注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comtext:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comtext:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comtext:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让人疑惑，这不是脱了裤子放屁，多此一举吗？我一次性全部扫描不行吗？答案当然是否定的。因为SpringMVC和Spring是两个容器，就像电影里说的一句台词：<em>朕赐给你</em>，<em>才是你的，朕不给</em>，<em>你不能抢</em>。所以Spring容器中的Controller组件没有在SpringMVC中注册，于是就会出现找不到路径这个错误。spring-mvc.xml这个配置文件时web.xml文件钦点给dispatcherServlet的，你Spring虽然是SpringMVC的父容器，但是Spring扫描到的Controller，SpringMVC容器中并没有，也就无法使用。</p>
<p>实例中还使用了大量的注解，来看看我们使用了哪些注解……</p>
<p><strong>Controller：</strong>这个就不用多说了吧，用于扫描Controller组件的。</p>
<p><strong>RequestMapping：</strong>见名知其意，一眼就看出来是用来映射的，值得注意的是这个注解不仅可以标注在方法上，还可以标注在类上，这样这个Controller所有的方法默认前缀都加上了一个类RequestMapping值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"class"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult&lt;List&gt; <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AjaxResult&lt;List&gt; ajaxResult = <span class="keyword">new</span> AjaxResult&lt;&gt;();</span><br><span class="line">        ajaxResult.setCode((<span class="keyword">short</span>) <span class="number">200</span>);</span><br><span class="line">        ajaxResult.setData(demoService.demo());</span><br><span class="line">        ajaxResult.setMessage(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> ajaxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，访问hello方法的url就是localhost:8080/class/hello。</p>
<p>说完value了，这个method又是什么玩意呢？这是RestFul风格的产物，简单说一下Restful风格吧：</p>
<p>RestFul风格是一种风格，而不是一种规范，就像我们左大括号写在类或者方法同一行，你可以不遵守，但是遵守了会优雅很多（大家协同工作，风格就是规范！）。这个风格要求什么呢？</p>
<ol>
<li>每一个url代表一个资源，比如user、session等等</li>
<li>使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源；POST用来新建资源；PUT用来更新资源；DELETE用来删除资源；</li>
</ol>
<p>还有其他要求，希望大家自行查阅，这里不再赘述。</p>
<p>可能有的同学没有看懂，那么我再解释一下：我们的需要对A资源进行获取操作，那么我们的url就是localhost:8080/A/。而不是localhost:8080/getA/。那么有同学问了，我如果要对A资源进行增加操作呢？还使用localhost:8080/A/不就撞了吗？Restful微微一笑，少年，你学过方法的重载吗？Java方法的重载是方法同名不同参，我Restful是同链不同方法。也就是相同的url，因为浏览器发出请求的方法不同，所调用Controller中的方法也不同。</p>
<p>实例中采用的是get方法，我们通过PostMan发出get方法的请求可以接收到返回的数据，如果我们发送post请求呢？</p>
<p>在方法下拉栏里选择post然后send</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711211759296.png" alt="image-20200711211759296"></p>
<p>返回一长串响应体：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP Status 405 – 方法不允许<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!--省略--&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTTP Status 405 – 方法不允许<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"line"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Status Report<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Request method <span class="symbol">&amp;#39;</span>POST<span class="symbol">&amp;#39;</span> not supported<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">b</span>&gt;</span> 请求行中接收的方法由源服务器知道，但目标资源不支持<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"line"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Apache Tomcat/9.0.33<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>报了405错误，我们都知道4xx开头的都是资源找不到，因为我们没有为hello这个资源定义method=post的RequestMapping。</p>
<p>我们在Controller中加上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.DELETE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"delete!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后通过PostMan的发出请求</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711214718197.png" alt="image-20200711214718197"></p>
<p>成功获取到想要的值。</p>
<p><strong>*注意：</strong>PostMan可以直接发送各种方法的请求，不代表浏览器也可以，HTML中的form表单仅支持get和post两种请求，需要在web.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个过滤器会将下面的form表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"put"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"userInfo"</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"userInfo"</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"delete"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是将form表单不支持的方法，变为参数通过post传递过去。</p>
<p>因为顺便讲了Restful的关系，RequestMapping占了很大的篇幅，希望大家还没有失去耐心。再给大家一个RequestMapping的省事小技巧：</p>
<blockquote>
<p> @RequestMapping(value = “hello”,method = RequestMethod.GET) </p>
<p> 可以转变为</p>
<p> @GetMapping(“hello”)</p>
</blockquote>
<p>同理其他几个方法也可以转变为XXXMapping的格式。</p>
<p><strong>ResponseBody：</strong>这个注解可以标注在方法和类上，标注在方法上说明方法的返回值将作为HTTP的响应体返回给浏览器，同理，标注在类上就说明这个Controller类的所有方法的头上都有了一个@ResponseBody，再来一个小技巧：</p>
<blockquote>
<p>@Controller</p>
<p>@ResponseBody</p>
<p>可以简写为</p>
<p>@RestController</p>
</blockquote>
<p>这个注解没什么好说的，只要记住被标注的方法返回值会被写进HTTP响应体中，如果没有JSON解析就会报错，因为SpringMVC也不知道你返回个Java对象怎么传。</p>
<p>我们见过的所有注解都已经讲完了，下面该讲一些我们没见过的注解了。</p>
<p>怎么获取浏览器发给我们的参数呢？</p>
<p>三种办法：form表单、Ajax提交和url，form和url我们都很熟悉，Ajax就是前端的事情啦。form就不讲了，这里讲讲Ajax，虽然Ajax是前端的事情，但是作为后端开发人员，学习Ajax还是有必要的。</p>
<p>先讲一讲Ajax提交请求，Ajax将数据封装JSON字符串到HTTP请求体中，然后提交给服务器。所以我们可以使用功能强大的PostMan模仿Ajax提交请求。</p>
<p>这里涉及到一个注解<strong>@RequestBody</strong></p>
<p>在上一实例的基础上创建一个实体类entity.User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//别忘了写getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DemoController添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult&lt;User&gt; <span class="title">getUser</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">    user.setAge(<span class="string">"22"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult&lt;User&gt;((<span class="keyword">short</span>) <span class="number">200</span>,<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行Tomcat</p>
<p>打开PostMan，设置请求体文本类型为json</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002118022.png" alt="image-20200712002118022"></p>
<p>点击Body -&gt; raw </p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712001319890.png" alt="image-20200712001319890"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userName"</span>:<span class="string">"zhouxx"</span>,</span><br><span class="line">    <span class="attr">"address"</span>:<span class="string">"blooog.top"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="string">"21"</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好之后点击send。</p>
<p>Idea控制台出现：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002345055.png" alt="image-20200712002345055"></p>
<p>PostMan响应界面出现</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002421678.png" alt="image-20200712002421678"></p>
<p>可以看到，Ajax将数据通过JSON字符串传递过去，通过@RequestBody注解 -&gt; fastjson 转化User对象。至此服务器接收Ajax请求完成。</p>
<p>form表单提交涉及到一个注解——<strong>@RequestParam</strong>，这个注解的使用方法也特别简单，看下面的例子：</p>
<p>html/jsp的form表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/user/login.do"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"num"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"num"</span>)</span> String num,</span></span><br><span class="line"><span class="function">                   @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</span></span><br><span class="line"><span class="function">                   HttpSession session) </span>&#123;</span><br><span class="line">    User user = userService.login(num, password);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        session.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modelAndView.setViewName(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequestParam中的value和表单中的input中的name一致。</p>
<p>Restful风格也可以使用url传递参数，例如localhost:8080/user/1就是对id=1的user进行操作。使用<strong>@PathVariable</strong>可以实现：</p>
<p>我们在原来例子中的Controller上添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>( <span class="string">"user/&#123;userName&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult&lt;User&gt; <span class="title">pathTest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable(value = <span class="string">"userName"</span>)</span> String userName) </span>&#123;</span><br><span class="line">    System.out.println(userName);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult&lt;User&gt;((<span class="keyword">short</span>) <span class="number">200</span>, <span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启Tomcat。</p>
<p>打开我们的PostMan，输入URL，把之前Body中的内容删除。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095515714.png" alt="image-20200712095515714"></p>
<p>Body上会有一个小绿点，提示里面有内容。</p>
<p>点击Send按钮发送请求。控制台显示：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095617698.png" alt="image-20200712095617698"></p>
<p>PostMan界面显示：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095808638.png" alt="image-20200712095808638"></p>
<h2 id="注解总结"><a href="#注解总结" class="headerlink" title="注解总结"></a>注解总结</h2><p>讲到这里大家歇一歇，我来总结一下上面接触到的注解。</p>
<p>与请求接收数据相关的有：</p>
<p>@RequestBody：接收JSON请求体，用法：标注在方法头上</p>
<p>@PathVariable：接收URL上的值，用法：标注在方法参数上，如果参数是对象，那么会根据setter方法自动注入</p>
<p>@RequestParam：接收Form表单的数据，用法：标注在方法参数前面</p>
<p>与返回数据相关的有：</p>
<p>@ResponseBody：将返回值作为HTTP的响应体，用法标注在类或者方法头上。</p>
<p>@RestController：可以看作是@Controller和@ResponseBody的结合</p>
<p>与路径相关的有：</p>
<p>@RequestMapping：可以标注在类或者方法上，值为该请求 -&gt; 方法的路径，标注在类上则为这个类中所有的方法加上前缀。</p>
<p>@GetMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为get。</p>
<p>@PostMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为post。</p>
<p>@PutMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为put。</p>
<p>@DeleteMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为delete。</p>
<h2 id="搞定完结"><a href="#搞定完结" class="headerlink" title="搞定完结"></a>搞定完结</h2><p>缕一缕这篇博客讲了什么：</p>
<ol>
<li>MVC是个啥</li>
<li>前后端分离的故事</li>
<li>SpringMVC和Spring不得不说的配置</li>
<li>优雅的Restful风格</li>
<li>开发利器PostMan</li>
<li>SpringMVC注解大家庭</li>
</ol>
<p>希望你能根据这6条回忆起这篇博客的内容。</p>
<p>这篇博客对HTTP协议、Servlet有一丢丢丢的要求，如果你看起来很吃力或者有任何疑问，欢迎询问。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>让人头疼的多线程：Volatile和线程可见性</title>
    <url>/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9AVolatile%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> 多线程编程一直是一个比较难的技术，知识点多而且复杂，脑子不好使的我曾经在这方面跌倒无数次，多线程中的每一个关键字都有可能牵扯出一大堆的技术问题，这篇博客就来深挖一下Volatile关键字。</p>
<a id="more"></a>

<h2 id="一段奇怪的代码"><a href="#一段奇怪的代码" class="headerlink" title="一段奇怪的代码"></a>一段奇怪的代码</h2><p>我们先来看看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        tt.flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.print(<span class="string">"main线程即将运行结束……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的逻辑非常简单，创建一个线程，不断循环，等待循环结束之后，输出i的值。循环的停止由主线程main控制，很多同学都会觉得答案是不固定的（取决于计算机性能，两秒钟跑多少次循环），那么究竟是不是这样呢？</p>
<p>控制台在两秒钟之后显示</p>
<blockquote>
<p>main线程即将运行结束……</p>
</blockquote>
<p>随后陷入漫长的等待，并没有i值的显示，只能主动结束程序运行。</p>
<p>为什么会这样呢？我希望大家能够认真思考这个问题，锻炼自己的思考能力，然后再往下看。</p>
<p>原来是JVM会对你的代码进行优化，负责这部分的是JIT组件（Just In Time Compiler），JIT会导致你运行的指令（你写的代码会被编译成Class文件，然后由JVM根据Class文件指挥操作系统执行更底层的指令）不是当初你写的代码，它会自作主张的帮你优化一些它认为需要优化的代码，以提高运行速度。</p>
<p>在这个例子中，它认为该线程中没有改变flag值的变量，那么它就会优化你的代码，想要偷偷少那么一个从内存中读取flag的过程，于是它把Flag的值（并非flag的地址）放到CPU中的一个缓存中，不再从内存中读取Flag的值了，另一个CPU对Flag进行写操作是写内存中的，所以这个写操作对另一个线程<strong>不可见</strong>。</p>
<p>程序被重排序为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//看下面</span></span><br><span class="line">                <span class="comment">//var会被缓存到CPU中，不再读取flag</span></span><br><span class="line">                <span class="keyword">boolean</span> <span class="keyword">var</span> = tt.flag;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">var</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.print(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        tt.flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.print(<span class="string">"main线程即将运行结束……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子中，JVM把语句的顺序（我们认为的语义）进行优化（出BUG）的过程叫做指令重排序。</p>
<p>那么很多问题接踵而来，为什么Java要指令重排序？有没有什么可以解决指令重排序导致的语义改变？</p>
<h2 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>接下来回答上面两个问题：</p>
<p>*<em>为什么Java要指令重排序? *</em></p>
<p>我们平常编写的代码对于开发人员来说很多细节都是被忽略的，但是对于计算机来说不同，例如下面这段程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x=<span class="number">100</span>;</span><br><span class="line">y=z;</span><br></pre></td></tr></table></figure>

<p>对于计算机来说，步骤是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将100值存到x中</span><br><span class="line">读取z的值</span><br><span class="line">将z值写进y</span><br></pre></td></tr></table></figure>

<p>对于CPU来说，过程是这样的：写 -&gt; 读 -&gt; 写。对于CPU来说，写过程需要额外等待IO（参考计算机组成原理中CPU的MESI协议），JVM为了尽快的使用CPU就会将单线程内语义无关的语句重新排序执行。JVM重排序的语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">y=z;</span><br><span class="line">x=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>CPU指令变成了读 -&gt; 写 -&gt; 写，这两条语句在我们看来语义是没有区别的，但是对于CPU来说提前运行了一丢丢丢的时间。</p>
<p>总体来说指令重排序就是为了压榨CPU的性能，充分利用CPU的时间片。</p>
<p><strong>怎么解决指令重排序所导致的语义改变？</strong></p>
<p>指令重排序必须遵循<strong>as if serial语义</strong>：即不论指令怎么重新排序，程序（单线程）的执行结果不能发生改变。指令重排序在单线程时是安全的，但是多线程的时候就有可能导致语义发生变化，线程之间的不可见性会导致线程之间不能正常通信。</p>
<p>有三种方法可以解决上面的问题：</p>
<ol>
<li><p>加上JVM参数： -Djava.compiler=NONE，这个参数会禁止JVM进行重排序，但是不推荐使用这种方法。网上有种说法：现在计算机计算速度很快，没必要再重排序，直接加上这个参数就能避免线程之间的不可见发生。</p>
<p> 博主不是很认同这种说法，博主认为正是因为CPU的运算速度很快，所以才要尽量缩减CPU的IO时间，否则CPU阻塞在IO什么也不做，那CPU速度再快又怎样呢？</p>
</li>
<li><p>使用volatile关键字：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        tt.flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"main线程即将运行结束……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行程序，出现我们想要的结果。</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200715212744310.png" alt="image-20200715212744310"></p>
</li>
<li><p>使用synchornized同步：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadTest tt = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        tt.flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"main线程即将运行结束……"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将i变量加入到同步代码块中，再次运行：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200715204900711.png" alt="image-20200715204900711"></p>
</li>
</ol>
<p>下面会详细讲解后两种方法解决问题的原理。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>上面使用volatile关键字修饰了flag变量，我们来百度一下volatile变量是用来干嘛的。</p>
<p>百度说：volatile 的特性有两个，保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的；禁止进行指令重排序。</p>
<p>情况真的是这样的吗？</p>
<p>我们查找一下JVM规范文档中的原话，说的是这一句：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200715215452358.png" alt="image-20200715215452358"></p>
<p>*这个文档不推荐大家直接看，而是应该结合其他人的博客，以这个作为标准参考。需要文档的可以发邮件给我索要。</p>
<p>被volatile修饰的field不能被缓存。并没有提到上面的两个特性，这是怎么回事呢？</p>
<p>我们回到上一个例子中，flag变量不可见的原因是什么？是JVM指令重排序进行了优化，将flag的值放入CPU缓存中。如果flag用volatile修饰，flag就不能被缓存进CPU，自然就解决了线程间不可见性的问题，每次都会CPU都会读取flag的值。volatile禁止指令重排序这个特性又是怎么回事呢？上面讲过了，重排序的例子中创建了一个新变量缓存到CPU中，flag被volatile修饰后，就不能再缓存了，如果JVM仍旧使用指令重排序就违反了as if serial语义，这就是为什么volatile能够禁止指令重排序的根本原因。</p>
<h3 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h3><p>上面说了volatile能够禁止CPU对变量（其实就是内存中的一部分区域）进行缓存，volatile通知JVM该变量不能被缓存，那么JVM何德何能控制内存能否缓存进CPU呢？毕竟CPU作为计算机的核心，JVM只是运行在操作系统上的一个软件而已，我CPU还不是想缓存谁就缓存谁？</p>
<p>然而，CPU自知自己有可能因为缓存犯错，所以提供了内存屏障，内存屏障使用了四条汇编级别的指令。volatile也是使用这四条指令来约束指令重排序的，下面讲一下volatile禁止重排序的规则。</p>
<ol>
<li>volatile的读操作的下一条操作不允许指令重排序</li>
<li>volatile的写操作下一条操作仅允许普通指令重排序，volatile操作不允许重排序</li>
<li>普通读写操作不允许下面一条volatile写操作重排序</li>
</ol>
<p>*注：volatile操作意思为操作被volatile修饰的变量，普通操作意思为没有被volatile修饰的变量</p>
<p>画一个表格来表示上述规则：</p>
<table>
<thead>
<tr>
<th>前一条操作（纵）\后一条操作（横）</th>
<th>普通读/写</th>
<th>volatile读</th>
<th>volatile写</th>
</tr>
</thead>
<tbody><tr>
<td>普通读/写</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>volatile读</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>volatile写</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="synchronized解决可见性原理"><a href="#synchronized解决可见性原理" class="headerlink" title="synchronized解决可见性原理"></a>synchronized解决可见性原理</h2><p>JSR-133（一群大佬开会发布的规范）规定synchronized获取锁前后保证线程的可见性，原理和volatile关键字相同。</p>
<p>那么我们看看synchronized放在哪里会生效:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">    <span class="comment">//加锁之前，读内存屏障</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁之后，写内存屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">    <span class="comment">//加锁之前，读内存屏障</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="comment">//释放锁之后，写内存屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是下面这种是不行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//加锁之前，读内存屏障</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(tt.flag)&#123;</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放锁之后，写内存屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为synchronized只会执行一次，下一次就不生效了，flag仍旧会被缓存进CPU中。</p>
<h2 id="synchronized和volatile的区别"><a href="#synchronized和volatile的区别" class="headerlink" title="synchronized和volatile的区别"></a>synchronized和volatile的区别</h2><p>例子中synchronized和volatile都能解决可见性问题，但是区别如下：</p>
<ol>
<li>synchronized作用于一段代码或者方法上，volatile用于修饰变量。</li>
<li>volatile不会造成线程的阻塞，synchronized可能会造成线程的阻塞。</li>
<li>volatile只保证线程的可见性，不保证线程的原子性，因为volatile只是让被修饰的变量不能缓存。synchronized能够保证可见性以及原子性，synchronized会将私有内存和公共内存做同步。</li>
<li>volatile比synchronized更省资源。例子中也可以看到，volatile在两秒钟内所做的循环比synchronized所做的循环多得多。</li>
</ol>
<p>上面的区别提到了原子性，原子性和可见性是线程安全的两个重要特点。</p>
<p>可见性我们已经说过了，线程对某一公共变量的修改对另一线程总是可见。volatile拒绝公共变量被私有缓存，每次读取和修改都让线程去内存中读取，保证了线程的可见性。</p>
<p>原子性是指线程的操作一旦开始就不可中断，也不会被其他线程所干扰。也就是当两个线程同时对一个变量操作的时候，结果可能不确定，但是结果一定是可以预测的a或者b两种结果。例如线程A对i进行加1操作，另一个线程B对i进行减1操作，例子中不论线程执行的先后，两个线程执行完毕之后i值总是不变。然而减一/加一并非是原子操作。它通常包含三个步骤：CPU从内存读取i；对i进行操作；将i写入内存。我们可以大胆假设，如果不保证原子性（也就是不把三个步骤看作一个步骤），可能会出现这种情况：</p>
<ol>
<li>A线程读取i值为0，此时B线程也读取了i值为0（此时A和B均未执行写操作）；</li>
<li>随后A线程对i值进行修改，A线程中i值为1，B线程此时也对i值修改，B线程中i值为-1；</li>
<li>A线程将自己的i值写到内存，此时i值为1；</li>
<li>B线程将自己的i值写到内存，此时i值为-1；</li>
</ol>
<p>很明显结果和我们预想的不符合，这就是线程中的原子性被破坏了，要怎么做呢？使用synchronized关键字就可以，A线程告诉B线程，我执行写操作的时候，你不能读，等我写完了你才能读，这就保证了线程的原子性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了以下知识点：</p>
<ol>
<li>线程不可见性的原因</li>
<li>指令重排序是什么？</li>
<li>volatile关键字有什么用？</li>
<li>volatile关键字的原理。</li>
<li>synchronized怎么解决可见性问题</li>
<li>v&amp;s的区别</li>
</ol>
<p>我们学习这些底层知识的目的不一定工作中用得到，只是为了培养一种计算机思维能力，不至于自己写的代码运行结果是什么都不知道。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Volatile</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>让人头疼的多线程：CRUD用得到多线程？</title>
    <url>/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9ACRUD%E7%94%A8%E5%BE%97%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>INTRO：</strong>多线程这个东西让人又爱又恨，爱的是它解决了CPU偷懒的问题，恨的是它复杂、知识多、日常难接触到。这三点交杂起来，真的是让人觉得脑壳疼，这篇博客就解决你的心头病，带你从头撸下多线程。</p>
<a id="more"></a>

<h2 id="嘛是多线程？"><a href="#嘛是多线程？" class="headerlink" title="嘛是多线程？"></a>嘛是多线程？</h2><p>线程：程序执行的最小单位。线程线程，一条线上的程序，我们把程序的执行当作一条线，从头到尾，中间可能有打结（循环结构），分叉（判断结构），但是并不影响我们从线头撸到线尾。</p>
<p>上面是单线程的情况，多线程就是有很多根线，CPU走走这条线，跑跑那条线，不专注在一棵树上吊死。</p>
<p>举一个生活中的例子，某妹子是一个专业养备胎二十年的老女神。她为了维护自己的女神形象无法让这些备胎见面，所以她只能敷衍过一个备胎之后再敷衍另一个备胎。某一天早晨，备胎A发消息说给女神买了早餐，一分钟后备胎B给女神发了早安，女神是应该先吃完A的早餐之后再回复备胎B，还是先回复备胎B的早安然后继续等A的早餐呢？</p>
<p>答案很明显是先把B的早安回了，毕竟闲着也是闲着不是？这个例子中女神就是CPU，两个备胎就是线程，是否知道线程的作用了呢？如果这个例子是单线程的，就会出现这种情况：备胎A给女神买了早餐，女神开始等待备胎A的早餐，一分钟后备胎B给女神发了早安，女神并没有看到，因为女神呆呆望着门口等待A的早餐，更别说回复了。</p>
<p>多线程的意义就在于此，把CPU等待IO的时间充分利用起来，CPU等待IO的时候，就给它安排计算，无情压榨。</p>
<p>既然多线程这么香，为什么不到处都用多线程呢，两个表达式就开一个线程岂不是速度飞起？</p>
<p>多线程还是有缺点的：</p>
<ol>
<li>线程的切换需要消耗系统资源。</li>
<li>线程的创建需要消耗大量系统资源。</li>
<li>线程之间的安全问题比较复杂。</li>
<li>多线程有可能发生死锁。</li>
<li>线程会占用额外的内存空间。</li>
</ol>
<p>这些缺点有些是可以避免的，能否避免、怎样避免就是我们为什么要学习多线程技术，也是多线程技术复杂的原因，因为它必须解决这么多的多线程缺陷。</p>
<h2 id="CRUD用得到多线程？"><a href="#CRUD用得到多线程？" class="headerlink" title="CRUD用得到多线程？"></a>CRUD用得到多线程？</h2><p>有同学要问了，我开发的项目都是用的Spring，无非就是增删改查，哪里用得到多线程嘛。</p>
<p>我们来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据用户id查询用户信息</span></span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> OrderInfo <span class="title">getOrderinfo</span><span class="params">(String userId)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据用户Id查询该用户的订单信息</span></span><br><span class="line">        <span class="keyword">return</span> orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设我们有一个界面需要调用这两个Service层方法，也就是某一Controller调用了这两个方法，并且将查询到的用户信息和订单信息打包成一个JSON字符串，而服务器架构是这样的：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200717123728495.png" alt="image-20200717123728495"></p>
<p>静态服务器做负载均衡，接收用户请求，动态服务器（Tomcat）集群用处理请求进行运算，数据库服务器存储数据。</p>
<p>如果不使用多线程，那么两个方法顺序执行，是这样的步骤：</p>
<ol>
<li>静态服务器接收到用户请求</li>
<li>静态服务器转发请求给动态服务器</li>
<li>动态服务器处理请求，先调用getUserInfo()方法向数据库服务器查询数据</li>
<li>数据返回到动态服务器，动态服务器调用getOrderInfo()方法向数据库服务器查询数据</li>
<li>数据解析成JSON字符串数据给静态服务器</li>
</ol>
<p>观察第4-5步，动态服务器调用getUserInfo方法之后需要向数据库服务请求数据，此时CPU进入闲置状态，因为CPU在等待数据库服务器返回数据，假设动态服务器到数据库服务器需要0.5s，那么这0.5s中大概有0.45s都是在浪费CPU。</p>
<p>使用多线程就不一样了，动态服务器向数据库服务器查询UserInfo数据的要求之后，该线程继续等待数据的返回，而是另一线程则紧接着发送查询OrderInfo数据的请求，并且自己等待数据的返回。（没错，这个叫做异步）</p>
<p>悄咪咪地说一句，Spring针对这种异步情况提供了一个注解——@Async，有时间讲一讲。</p>
<h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><p>学习多线程的第一步当然是创建几个多线程玩玩啦！</p>
<p>创建多线程有两种方式：</p>
<p>继承Thread并且重写run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"blooog.top"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread0().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Runnable接口重写run方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"blooog.top"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread0()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终还是要把Runnable类传递到Thread中，Runnable也就图一乐，真要用线程还是Thread。既然如此为什么要使用Runnable呢？因为Java不支持多继承，一个类只能有一个爹，而且实现Runnable接口更能体现面向接口编程的开发理念。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>通过Thread的源码我们可以得知Java线程一共有六种状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NEW：新建状态，线程对象刚创建，还没有调用start()方法跑起来。这里提一句，run方法和start方法一定要分清楚，run方法是你告诉计算机打算开启一个新线程运行run方法中的代码，start方法才是开始新线程。</p>
<p>RUNNABLE：就绪状态，表示线程随时都可以运行，这个状态可能发生在刚调用线程的start方法、sleep方法时间到了，从wait状态被唤醒、CPU正常切换到另一个线程。</p>
<p>BLOCKED：阻塞状态，表示线程暂时不能运行，处于等待锁的状态，例如运行到synchronized关键字。</p>
<p>WAITING：等待状态，表示线程当前正在等待另一线程唤醒，通常使用wait()，join()等进入。</p>
<p>TIMED_WAITING：带时间的等待状态，例如sleep方法，时间到了就自然进入RUNNABLE状态。</p>
<p>TERMINATED：销毁状态，线程逻辑也就是run()方法执行完毕，不需要再调度该线程。</p>
<p>用一个图可以表示这六种状态的相互转换：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200717141332216.png" alt="image-20200717141332216"></p>
<p>可以把这几种状态比作皇帝后宫妃子的状态。</p>
<p>NEW：选进宫中，进行培训（哪有刚来就被皇上宠幸的）。</p>
<p>RUNNABLE：随时可以被翻牌子，等待皇上宠幸。</p>
<p>BLOCKED：被得宠的妃子欺压，打进冷宫，等到得宠的妃子释怀（释放锁）才能继续被皇上宠幸。</p>
<p>WAITING：不孕不育，除非别的妃子或者来了神医，否则皇上再也不宠幸你了。</p>
<p>TIMED_WAITING：来大姨妈，时间到了恢复可以被皇上宠幸的状态。</p>
<p>TERMINATED：完成妃子的终极目标，怀孕了……不用伺候皇上了。</p>
<p>有一说一，感觉全网没有比这个更加形象的比喻了……但是BLOCKED的比喻不是很符合，凑合看吧。</p>
<h2 id="线程相关的方法"><a href="#线程相关的方法" class="headerlink" title="线程相关的方法"></a>线程相关的方法</h2><p>讲过了线程状态的切换，下面就需要讲一讲线程之间切换状态所使用的方法了。线程相关的方法按照调用方式可以分为三种，对象方法，该方法属于对象，由对象调用；静态方法，该方法属于Thread类，调用该方法会作用于调用者；Object继承的方法，该方法继承自Object类。</p>
<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p><strong>start()：</strong>这个方法使线程从NEW状态变为RUNNABLE状态</p>
<p><strong>getState()：</strong>获取线程当前的状态</p>
<p><strong>interrupt()：</strong>中断当前线程</p>
<p><strong>join()：</strong>等待指定线程完事才能继续运行，如果使用有参的join()方法的话，就是等指定线程完事或者经过指定毫秒。被插队的线程进入WAITING状态。</p>
<p>上面是Thread对象的常用方法（其他getter和setter方法就不列出来了）。</p>
<p>简单说一下interrupt()方法吧。</p>
<p><strong>中断：</strong>用一把剪刀把线程剪短，不让线程继续进行下去。然而Java中的中断机制并没有剪刀剪线头那么利落。Java中调用interrupt()方法是给线程一个中断标记，具体怎样处理还是要看线程自己，线程觉得自己工作很重要，就不理会中断标志位，而是继续执行下面的语句。</p>
<p>还有两个名字很像的方法难以区分，interrupted和isInterrupted。interrupted()是个静态方法，返回当前线程的中断状态（不管你是调用哪个线程对象的interrupted()方法，这条语句哪个线程执行就是哪个线程的中断状态），并且清除线程的中断标记。isInterrupted()不是静态方法，返回线程对象的中断状态，不会清除中断标记。</p>
<p>说到中断，曾经有一个stop()方法可以强制结束线程的生命，后来被弃用了。调用线程对象的stop方法会立刻释放该线程对象的锁和线程资源。例如一个程序在转账过程中被中断，转出成功但是还没转入目标账户，用户钱凭空消失！你永远也不知道调用一个线程的stop()方法时这个线程在干什么。所以现在中断方式由命令中断，改为请求中断，由线程自己决定要不要中断。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>sleep()：</strong>调用该方法的线程会进入TIMED_WAITING状态，等待事件结束之后，自动恢复RUNNABLE状态。</p>
<p><strong>yield()：</strong>放弃当前的CPU使用权，也就是皇上翻了某妃子的牌子，妃子说皇上您再重新选一次，皇上有可能再次翻该妃子的牌子，也有可能翻其他妃子的牌子。</p>
<p><strong>interrupted()：</strong> 这个讲过了，请看上面中断部分。</p>
<p><strong>currentThread()：</strong>获取当前线程的线程对象。例如我们实现Runnable接口的时候，此时当前线程对象是Runnable类型，无法使用上一章节的非静态方法，此时可以调用currentThread()方法获取Thread对象，然后通过对象来调用非静态方法。</p>
<p><strong>activeCount()：</strong>返回当前线程组存活的线程。</p>
<h3 id="Object的遗产方法"><a href="#Object的遗产方法" class="headerlink" title="Object的遗产方法"></a>Object的遗产方法</h3><p><strong>wait()：</strong>这个方法是从Object继承过来的，它会让线程释放锁，并且进入WAITING状态。看起来和sleep很相似，后面会详细讲解wait和sleep的区别。</p>
<p><strong>notify()/notifyAll()：</strong> 这两个方法也是从Object继承过来的，notify方法会唤醒处于wait的线程。</p>
<p>注意：wait()和notify()都必须放在同步代码块或者同步方法中。</p>
<h3 id="wait-方法和sleep-方法的区别"><a href="#wait-方法和sleep-方法的区别" class="headerlink" title="wait()方法和sleep()方法的区别"></a>wait()方法和sleep()方法的区别</h3><p>上面我们了解到wait方法和sleep方法都会让线程进入WAITING/TIMED_WAITING状态，两者有以下区别：</p>
<ol>
<li>血统不同：wait方法继承自Object，而sleep是Thread类的一个静态方法。</li>
<li>对待锁的方式不同：sleep不会释放锁，只是把CPU让出来。wait不仅会让出CPU，还会释放锁。</li>
<li>运行环境不同：sleep在哪都可以运行，wait只能运行于同步代码块/同步方法中</li>
</ol>
<h2 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h2><p><strong>线程优先级：</strong>在Java中，每个线程都有自己的优先级，并且子类可以继承父类的优先级。可以通过getter和setter方法获取或者设置线程的优先级。Java将线程的优先级分为10个等级，并且提供了三个常量：MIN_PRIORITY=1;MAX_PRIORITY=10;NORM_PRIORITY=5。</p>
<p>线程调度器准备执行新线程时，会优先选择较高优先级的线程，但是线程优先级依赖于系统。不同的平台可能对线程的优先级处理不同，例如Windows中线程的优先级分为七个等级，而Oracle为Linux提供的JVM没有线程优先级这个概念，所有线程优先级是平等的。</p>
<p>所以不要过度依赖线程优先级，程序的正确性如果依赖于线程优先级，那么不同的平台可能会出现不同结果。</p>
<p>另外，低优先级的线程可能一直无法执行，导致低优先级的线程饿死。</p>
<p><strong>守护线程：</strong> Java中设置了一个标志位——Daemon，这个标志位表示该线程是否是一个守护线程。先来介绍一下守护线程，守护线程唯一的作用就是给其他线程提供服务，例如提供计时功能。</p>
<p>值得讨论的是守护线程的生命周期，守护线程不是妃子，守护线程是妃子的丫鬟，当所有的妃子都嗝屁了之后，守护线程也会随之嗝屁，因为守护线程没有提供服务的对象了，也就没有存在的必要了。</p>
<p>这里提醒大家：千万不要让守护线程访问数据库，就像之前说的stop方法一样，你永远不知道守护线程什么时候嗝屁了。</p>
<p><strong>线程组：</strong> 为了方便管理线程，Java推出了线程组这一概念。Thread的构造方法提供了线程组的参数，传入所在线程组的对象。假设A线程创建了B线程，并且B线程的构造方法没有设置线程组对象，那么默认B线程和A线程同属于一个线程组。</p>
<p>然而，大家在程序中尽量避免使用线程组。因为Java引入了更好的线程管理集合。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了：</p>
<ol>
<li>什么是多线程</li>
<li>多线程关Spring CRUD什么事</li>
<li>线程的状态和转化</li>
<li>线程相关的方法</li>
<li>wait和sleep方法的区别</li>
<li>线程的属性</li>
<li>线程优先级好不好使？</li>
<li>守护线程是个啥？</li>
</ol>
<p>多线程的知识还是有点多的，尽管都是很基础的东西，但是以自己的水平写出来还是比较吃力的。这篇博客写了两天，还是有很多知识没有提及，比如多线程中的异常处理机制。有时间的话再另写一篇博客补充上去吧。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>让人头疼的多线程：synchronized暴打线程安全</title>
    <url>/%E8%AE%A9%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9Asynchronized%E6%9A%B4%E6%89%93%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><strong>INTRO：</strong>线程安全是什么？我就头铁不加锁。性能是什么？我每个方法都来一个synchronized。这篇博客synchronized原理入手，教你怎样合理利用synchronized写出性能和安全兼顾的代码。</p>
<a id="more"></a>

<h2 id="JVM的内存模型——JMM"><a href="#JVM的内存模型——JMM" class="headerlink" title="JVM的内存模型——JMM"></a>JVM的内存模型——JMM</h2><p>说到线程安全，就不得不讲讲Java中JVM的内存模型JMM（Java Momory Model）。</p>
<p>JMM定义了Java在内存中运行的模式，简单来说就是Java在运行时的数据在内存中以怎样的形式存放。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200720101831305.png" alt="image-20200720101831305"></p>
<p>上面这张图来来自《深入理解Java虚拟机》，上面的区域可以分为两类，线程共享的区域和线程隔离的区域。线程隔离的区域是线程私有的，其他线程不能访问该区域中的数据，自然也就不存在线程安全的问题。</p>
<p>这里简单对这些内存区域做个介绍：</p>
<p><strong>方法区：</strong> 方法区和堆内存一样，是线程共享的区域，它用来存储类信息、静态变量、常量（常量也是静态变量呀）等数据。（有没有发现都是类相关的？）</p>
<p><strong>堆内存：</strong>一般来说，堆内存是JVM中最大的一块内存。这一大块内存只用来存放对象，几乎所有的对象都会被分配在堆内存中，记住这个几乎，并不是所有的对象都会分配在堆内存中，根据逃逸分析等优化技术会让对象分配在栈内存或者进行标量替换（只要机制不是所有的对象都分配在堆内存就行了，逃逸分析和标量替换有机会再讲）。</p>
<p>堆内存被所有线程所共享，存储数据重要+线程共享就导致了堆内存的线程安全问题是我们重点关注的内容。</p>
<p><strong>虚拟机栈：</strong>通常我们称之为栈内存，栈内存描述的是Java方法的内存模型，一个方法运行时就会创建一个栈帧，栈帧中存放方法的各种信息，例如局部变量表、程序出口。相信大家都知道栈这个数据结构，方法执行的时候会入栈，方法执行完毕会出栈。（想一想main线程中栈内存的栈底是不是永远是main方法？其他线程中栈内存的栈底是不是永远是run方法？）</p>
<p> <strong>程序计数器：</strong> 这块区域比较小，它用来作为当前代码所运行的行号指示。字节码解释器通过改变程序计数器的值来选择下一条运行哪条指令，判断、循环、异常处理等等。比如线程进行切换的时候需要保存原线程的程序运行到哪一条指令，所以每个线程都有一个程序计数器来记录运行的行号。</p>
<p><strong>本地方法栈：</strong> 这个区域和虚拟机栈一样，只不过本地方法栈服务于Native方法（非Java方法，通常是C/C++）。</p>
<p>这里给一些代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;<span class="comment">//存储在Test的对象中</span></span><br><span class="line">    Object object = <span class="keyword">new</span> Object();<span class="comment">//对象存放在堆内存，地址存放在Test的对象中。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE = <span class="number">1</span>;<span class="comment">//存放在常量池中，常量池属于方法区</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="comment">//obj存放在堆内存中，传进来的是obj地址的副本，这个地址存放在栈内存中</span></span><br><span class="line">        <span class="keyword">this</span>.object = obj;</span><br><span class="line">        Object obj2 = <span class="keyword">new</span> Object();<span class="comment">//在方法中创建的对象存储在堆内存中（不一定），地址存放在方法栈中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一句，在学习编程的时候都听说过两个概念，值传递和引用传递。也许有同学听说过这么一句话，Java中只有值传递，没有引用传递。Java方法的参数为对象时，传进来的是Java对象地址的副本。可能说起来有点难懂，我们看一下代码就明白了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.test(t.object);</span><br><span class="line">        System.out.println(t.object == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考一下，如果Java中的方法是引用传递，也就是t.object的地址传递进test方法，然后被设置为空值，那么this.object是否就为空了？也就是程序运行结果为true。然而正确的运行结果是true，也就是说，Java传递过去的是一个地址的副本，这个副本相当于Java对象的代言人，你可以通过这个代言人对对象进行操作，但是你把代言人杀了，和原来的对象无关。</p>
<p>不好意思……扯远了，我们说回来。</p>
<p>上回书说到Java的内存模型，理解了Java的内存模型才能明白什么样的线程是安全的，什么样的线程是不安全的。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>我们先来写一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread0 t = <span class="keyword">new</span> Thread0();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (t.i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    t.i--;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + t.i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑很简单，开启三个线程对类变量i进行减操作，按照我们的想法应该是99-0，没有重复和缺失完整输出。</p>
<p>然而会出现这种现象：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200717105635486.png" alt="image-20200717105635486"></p>
<p>98出现了两次，并且没有99出现？在我们看来线程中仅仅两条语句，然而对于CPU来说，这两条语句分为四步：</p>
<ol>
<li>读取i的值到线程私有内存中</li>
<li>对私有内存中的i值进行修改</li>
<li>将i值写入到私有内存中</li>
<li>再次读取i值，并且打印到控制台</li>
</ol>
<p>那么一定是出现了某种操作，让数字99还未被第四步读取打印的时候就被改写了。例如线程0先读取i值并且进行操作写入，还未进行读取的时候，线程1再次读取i=99值，并且操作写入i=98。随后线程0再次读取i值，读到的是98。</p>
<p>我们再来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread0 t = <span class="keyword">new</span> Thread0();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (t.i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        t.i--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + t.i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与上面的代码没有什么太大变化，只是加了一个很复杂的关键字synchronized，这里先简单说一下它的作用：保护代码块中的代码只会被一个线程执行。</p>
<p>思考下上面的代码会出现什么结果，能修复之前遇到的问题吗？</p>
<p>来看一下运行结果：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200717111502567.png" alt="image-20200717111502567"></p>
<p>之前的98重复倒是解决了，可是又出现了一个新的问题——负值。（如果没出现就多运行几次，甚至可能会出现-2）</p>
<p>还是上面的步骤，很明显上面的原因全是synchronized的锅，下面讲一下这个synchronized究竟是什么。</p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized是解决线程安全问题最简单的方法，这个关键字可以保证在方法/代码块运行的时候只有一个线程访问。</p>
<p>synchronized有两种用法：</p>
<ol>
<li><p>修饰方法（静态方法也可以）</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">float</span> num)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            from.setBalance(from.getBalance() - num);</span><br><span class="line">            to.setBalance(to.getBalance() + num);</span><br><span class="line">            System.out.println(from.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰代码块</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">float</span> num)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                from.setBalance(from.getBalance() - num);</span><br><span class="line">                to.setBalance(to.getBalance() + num);</span><br><span class="line">                System.out.println(from.getBalance());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>synchronized关键字的参数：</strong>可能有的同学发现了修饰代码块的时候一个很奇怪的写法——synchronized (this){}，为什么要把当前对象传进去呢？其实这里用什么对象都可以，该对象作为锁的存在。代码块就像是一个房间，这个对象就是门的存在，这个神奇的门有一个规则，谁想进就能进，但是一次只能进一个人，第二个人想进只能等前面的人出来才能进。</p>
<p>再来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//this作为锁</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncThread s1 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        SyncThread s2 = <span class="keyword">new</span> SyncThread();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(s1, <span class="string">"Thread1"</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(s2, <span class="string">"Thread2"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run方法中的就不用看了，主要看main方法中怎么创建线程的，这里创建了两个SyncThread的对象，分别传入两个线程中。现在问大家一个问题：this对象是谁的对象？很明显是SyncThread的对象。再一个问题，现在堆内存中有几个SyncThread的对象？new了两个SyncThread()，当然是两个对象。那么最后一个问题，现在堆内存中有几把锁？我们使用this -&gt; SyncThread的对象作为锁，现在堆内存中有两个对象，那么就有两把锁。Thread1运行的是s1中的同步代码块，获取的是s1这把锁，然后美滋滋的执行。Thread2运行的是s2对象的同步代码块，获取的是s2这把锁，也可以美滋滋的执行。也就是说s1和s2是两个厕所，并没有同步的需要。</p>
<p>为什么会这样呢？因为Thread1和Thread2操作的不是一个对象呀！那么为什么要进行同步呢？</p>
<p>假设我在淘宝上买东西，在我付款的时候所有的人都没有办法付款，假设我付款需要一秒钟，淘宝一个小时才能成交3600单。你这不是并发，你这是恶霸呀！真正正确的方法是锁住我这个对象，</p>
<p>给大家一个恶霸写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(ThreadTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//吃饭</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个写法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="comment">//吃饭</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写是因为锁对象越小，性能越高（我没试过，但是理论上可行，大家也都是这么做的）。这里定义内部类的时候使用了static关键字，原因是保证Lock是唯一的（class只加载一次，在一个虚拟机中一个类只有一个class），也就是我吃饭的时候，全世界人都得端着碗看我吃，等我吃完之后，下一个拿到锁的人才能继续吃饭。</p>
<p>只锁住对象的可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    </span><br><span class="line">    ThreadTest()&#123;</span><br><span class="line">        lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            <span class="comment">//吃饭</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下：</p>
<p>synchronized可以用于方法和代码块，也就是分为四种情况：</p>
<ol>
<li>作用于普通方法</li>
<li>作用于静态方法</li>
<li>作用于代码块，参数为对象</li>
<li>作用于代码块，参数为.class</li>
</ol>
<p>其中1和3是等价的，它们锁住的都是对象，也就是同一个对象的代码块不能被多个线程执行。2和4是等价的（锁的范围），也就是同一个类的代码块不能被多线程访问。</p>
<h2 id="单例模式中的synchronized"><a href="#单例模式中的synchronized" class="headerlink" title="单例模式中的synchronized"></a>单例模式中的synchronized</h2><p>单例模式我们都会写，随手就写出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            System.out.println(<span class="string">"单例被创建"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的就写出来了，这个时候我们测试一下，看是不是只有一个实例。</p>
<p>写一个测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Singleton.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Singleton.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即创建两个线程获取instance，理论来说我们应该只获取的一个单例，也就是单例只被创建一次。然而多次运行（看运气）之后，出现了</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200721190048019.png" alt="image-20200721190048019"></p>
<p>也就是对象被创建了两边，我们的单例不是单例了！</p>
<p>相信经过上面的学习，你已经知道了为什么会发生这种情况，并且明白如何避免这种情况，无非就是在进入判断之前进行加锁。</p>
<p>代码改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            System.out.println(<span class="string">"单例被创建"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过多次运行之后，再也没有出现创建两个单例对象的情况出生了。</p>
<p>然而，还有一个隐藏的问题，代码的速度因为锁的原因降低了，每次我们调用get方法的时候都要加锁、判断、返回值，大大降低了我们的速度。</p>
<p>所以有一种双重校验锁的方式来解决这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    System.out.println(<span class="string">"单例被创建"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用这种双重校验锁的功能，我们可以得到一个性能和安全兼顾的单例模式。当然，还有一种方式更为简单，那就是枚举模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全问题新解决"><a href="#线程安全问题新解决" class="headerlink" title="线程安全问题新解决"></a>线程安全问题新解决</h2><p>现在我们来分析之前那个问题，使用synchronized为什么会出现负值。</p>
<p>忘记什么问题了吗？代码重新放一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread0 t = <span class="keyword">new</span> Thread0();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (t.i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        t.i--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + t.i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果也重放一下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200717111502567.png" alt="image-20200717111502567"></p>
<p>经过上面的学习，我们知道同步代码块并没有对while进行同步，也就是线程2和线程3在while循环后等待线程1执行同步代码块中的操作，等到线程1执行完毕，线程2/3才能继续进行操作。</p>
<p>例子中，也就是当i=1的时候，Thread-0和Thread-2（如果此时Thread-1也去读取i值的话，那就会有-2出现了）同时完成while的判断，然后Thread-2抢到了锁，进入代码块执行，Thread-0在代码块外等候。Thread-2执行完毕后，i值由1减为0并且Thread-2离开代码块释放锁，随后Thread-0抢到锁之后执行代码块，读取i值为0，将i-1（此时没有判断了，判断在同步代码块外面）的值写入内存。</p>
<p>那么怎么改善这种情况？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread0 t = <span class="keyword">new</span> Thread0();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                	<span class="keyword">while</span> (t.i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//为了看的更清楚一点</span></span><br><span class="line">                                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        t.i--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + t.i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果把代码改成这样，我们来看一下结果：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200721230845508.png" alt="image-20200721230845508"></p>
<p>结果发现Thread从99到0完全输出，也就是while循环完全是谁先抢到锁谁做完，继续改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread0</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread0 t = <span class="keyword">new</span> Thread0();</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (t.i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//为了看的更清楚一点</span></span><br><span class="line">                                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                            t.i--;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + t.i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，又是双重校验锁的方式来实现了，只不过这个是为了保证线程的安全，而非性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了什么：</p>
<ol>
<li>JMM有哪些区域</li>
<li>线程安全是什么</li>
<li>synchronized关键字的作用</li>
<li>synchronized关键字的四种用法</li>
<li>性能与安全兼顾的双重校验锁</li>
</ol>
<p>synchronized只是很简单的提了一下用法，更深层次的讲解我会抽时间写出来，最近要准备找工作了。祝我好运啦！</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程安全</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>强撸Java基础：一键掌握IO框架和装饰者模式</title>
    <url>/%E5%BC%BA%E6%92%B8Java%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%B8%80%E9%94%AE%E6%8E%8C%E6%8F%A1IO%E6%A1%86%E6%9E%B6%E7%9A%84%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> Java中的IO类有多复杂相信学习过的人都接触过，觉得IO框架复杂那是没有掌握它的设计思想，死记硬背不是好方法，只有掌握思想才能灵活运用。本文就从设计思想入手，从零开始讲解Java IO框架。</p>
<a id="more"></a>

<h2 id="为什么要有IO框架"><a href="#为什么要有IO框架" class="headerlink" title="为什么要有IO框架"></a>为什么要有IO框架</h2><p>我们知道计算机的核心是CPU，CPU直接与内存交互，内存又和其他设备进行交互。我们平常的代码都是运行在内存中的，那么我们怎么和其他设备打交道呢？比如我们的硬盘、鼠标、显示器等等。我们的数据怎么存储呢？内存一断电，我们的程序的数据就丢失了，这个数据如何持久化呢？有的同学说了，我用mysql等数据库持久化呀。新问题又来了，数据库怎么持久化存储数据的呢？另一个问题，数据怎么发送到数据库呢？</p>
<p>也就是说，程序设计语言需要一个让程序和除本机内存之外的其他设备进行交换数据的方法。</p>
<p>OK，知道为什么要有IO之后，我们先来思考如何解决这个问题，既然大家都是计算机的组成部分，那么1和0大家都认识吧？我们就通过二进制传输数据，这个1和0源源不断的传输过去，就像流水一样，我们就叫他字节流吧。</p>
<p>输入输出又怎么看呢？</p>
<p>我们是程序的编写者，当然要站在程序的角度看问题，数据读取到程序中就是输入，数据写到其他设备就叫输出。</p>
<p>区分好输入和输出，IO就可以分为两类了，输入流和输出流。</p>
<h2 id="InputStream和OutputStream"><a href="#InputStream和OutputStream" class="headerlink" title="InputStream和OutputStream"></a>InputStream和OutputStream</h2><p>上面说到内存和其他设备准备用字节为单位传输数据，于是自然分成了字节输入流和字节输出流两个类——InputStream和OutputStream。这两个类可谓是Java IO框架中的基石，其他类都是从这两个类中扩展出来的。因为计算机的底层传递的数据就是有0和1组成的bit流，bit流又以字节为单位进行传输。</p>
<p>输入流和输出流面对的对象比较广泛，小到鼠标，大到显示器，这些外设没有不认识bit流的。然而，只有这两个类就够了吗？并不是，你看显示器和硬盘的接口一样吗？鼠标和键盘的接口一样吗？很明显，这两个类直接拿来使用会不太好用。我们针对不同的外设加点不同的料（装饰模式）。</p>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>想要学习IO框架的思想，必须了解装饰模式是什么。这部分的知识来自《Head First 设计模式》，很推荐大家看一下这本书，简单易懂，可以让大家最快的了解设计模式。</p>
<p>先来一个装饰模式的例子：说的是星巴兹咖啡（这个咖啡店不存在，如果你搜索星巴兹，结果一定是装饰模式）更新了自己的订单系统，他们的订单系统有一个超类——Beverage，类中有一个方法叫做cost()，用于计算该饮料的花费。所有的饮料都继承自这个超类，这个大家都能理解，因为咖啡、牛奶、茶都是属于饮料的一种，价格也不一样嘛。</p>
<p>然而还有一个问题，咖啡中可以加入各种配料，比如豆浆（话说外国人喝豆浆吗？）、酸奶、巧克力等等，他们按照之前的想法就顺便创建了加了豆浆的咖啡、加了酸奶的咖啡、加了巧克力的咖啡、加了豆浆和巧克力的牛奶、加了酸奶的牛奶、加了巧克力的牛奶……等等等等排列组合个类。</p>
<p>程序员不怕苦不怕难，类多就类多吧，然而出现了一个新配料……芋泥，又要创建&amp;%&amp;*%个类，每次添加新的配料，我们都要增加倍数增长的类，这谁顶得住呀！而且如果配料的价格发生变化，哦豁，和这个配料相关的所有类都需要修改。</p>
<p>于是大佬想了一个办法——我们通过套娃的方法对饮料进行操作，举个例子吧，实现加了豆浆和巧克力配料的牛奶。</p>
<p>从牛奶（Milk）对象开始，Milk继承自超类Beverage，并且继承了一个cost()方法，如果我们想加入豆浆这个配料，那么我们也把豆浆继承Beverage类，所以它里面也有cost()方法的存在。同理，巧克力配料也继承Beverage类。</p>
<p>我们将豆浆加进牛奶中，也就是使用豆浆把牛奶装饰起来。再加入巧克力，使用巧克力把豆浆和牛奶装饰起来。估计很多人到这里就听不明白了，什么装饰来装饰去的。</p>
<p>直接上豆浆配料的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMilk</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Beverage beberage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cost;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanMilk</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cost + <span class="keyword">this</span>.beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧克力配料的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Beverage beberage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cost;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">this</span>.beverage = beverage;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cost + <span class="keyword">this</span>.beverage.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是有点明白了？</p>
<p>再来一个单品牛奶的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> cost;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Milk&#123;</span><br><span class="line">        <span class="keyword">this</span>.cost = <span class="number">30</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写一个调用的main代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//买牛奶，当然要先创建牛奶对象啦！</span></span><br><span class="line">        Beverage b = <span class="keyword">new</span> Milk();</span><br><span class="line">        <span class="comment">//将牛奶对象加入到豆浆</span></span><br><span class="line">        b = <span class="keyword">new</span> BeanMilk(b);</span><br><span class="line">        <span class="comment">//将带着牛奶对象的豆浆对象加入到巧克力</span></span><br><span class="line">        b = <span class="keyword">new</span> Chocolate(b);</span><br><span class="line">        System.out.println(b.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道大家现在是否明白装饰模式的实现，也就是装饰者增加行为到被包装的对象上。</p>
<h2 id="I-O-PutStream和它的子民们"><a href="#I-O-PutStream和它的子民们" class="headerlink" title="I/O PutStream和它的子民们"></a>I/O PutStream和它的子民们</h2><p>言归正传，回到Java IO，我们可以发现，而所有类的爸爸InputStream和OutPutStream就是上面例子中的Beverage。</p>
<p>那么我们常用的一些读写流（也就是我们出售的单品，牛奶咖啡茶等等）有什么呢？</p>
<p><strong>FileInputStream和FileOutputStream:</strong> 我们经常操作文件，比如把数据写入文件，或者从文件中读取数据。既然是文件的读写流，那么操作的对象就是File了，所以我们需要把文件对象传进File读写流，告诉Java读从哪读，写从哪写。这里的File不是指文件，而是操纵系统的文件系统，但是大家理解为文件就行了。这个常用，是重点。</p>
<p><strong>ByteArrayInputStream和ByteArrayOutputStream：</strong>字节数组输入输出流，这个只是在内存中自娱自乐，存在的意义就是把数据变成字节数组流，可以使用toString()方法获取，Tomcat中用过这个，因为不停转换为String太浪费性能了，所以直接使用这个流对数据进行操作过滤。</p>
<p><strong>PipedInputStream和PipedOutputStream：</strong>管道输入输出流，用于多线程之间的管道通信，用的不太多。</p>
<p><strong>ObjectInputStream和ObjectOutputStream：</strong>看名字就知道是干嘛的，对象和基本类型做持久化的，偶尔会用。</p>
<p>大概就这些了吧……有遗忘的我再补充，欢迎大家提醒补充。</p>
<p>讲完牛奶咖啡茶这些单品，我们来看配料都有哪些</p>
<p><strong>PushbackInputStream：</strong>回退流，这个配料会给单品带来怎样的口感呢？首先我们需要了解什么是回退，我们读取数据流的时候都是从头到尾顺序读，中间不能中断。回退就是数据流中出现我们不想要的数据我们把这个数据塞回去，然后结束读取。</p>
<p>举个例子：→14245507342433右，比如我们不想要数据0，我们就从1424开始读取，读呀读，读到0。发现不是我们需要的数据，我们就把0给塞回去，只要142455就行了。</p>
<p>具体的使用方法请查询文档，我在这里只介绍它的功能，大家知道有这么个类就行了。</p>
<p><strong>BufferedInputStream和BufferedInputStream：</strong>这个是我们经常用的配料流（别跟别人说配料流，我只是为了类比上面的例子，自己造的词）。因为一次一次的读写流要耗费大量的系统资源，就像一百辆车送一百件快递一样，将单品流的对象传给这个流，可以实现带有缓冲区的单品流。这个经常用！这个经常用！这个经常用！几乎所有的流都要用这个。</p>
<p><strong>DataInputStream和DataOutputputStream：</strong>这个流专门用来将各种基本类型（字符串也行）的数据写进读出一个流的，值得注意的是，两者要一起配合使用，并且读取要和写入的顺序一样，否则就会驴唇不对马嘴。</p>
<p><strong>PrintStream：</strong>看源码System类的源码就知道，System.out就是PrintStream的一个实例，所以这个用的多不多大家应该都明白。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final static PrintStream out &#x3D; null;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="另一个王国——Writer和Reader"><a href="#另一个王国——Writer和Reader" class="headerlink" title="另一个王国——Writer和Reader"></a>另一个王国——Writer和Reader</h2><p>话说I/O PutStream虽然强大，底层的东西都能读都能写，但是也不是所有的数据它都认识。例如：文本文件，英文的还好，英文使用ASCII码表，一个字节键盘上能敲出来的所有字母符号都能表示，使用字节流也能读取。那中文的文本文档可咋整呢？一个字节总共八位，还有一个得是0，ASCII码最多也就表示127个汉字就完犊子了，一个字节一个字节读取的都是乱码。所以中文使用Unicode，里面一百多万个字符随便用，GB就别说了，一不小心就乱码。</p>
<p>所以另一个需求出现了，读文本文件，还是一个字占好多字节的那种。Writer和Reader应运而生，这两个哥们专门针对各种文本文档的读写。它们两个也是作为超类的存在，也有一大堆子民。</p>
<p>先来看看单品有哪些：</p>
<p><strong>FileWriter和FileReader：</strong>这两个就是专门用于字符的读写流了。和FileInputStream一样，我就不再赘述了。这个也很常用，重点！想当年我自己整了一个文本文档作为项目的数据库……那个对字符串的各种操作算法……不敢回想。</p>
<p><strong>PipedReader和PipedWriter：</strong>不常用，多线程通信字符。</p>
<p><strong>StringReader和StringWriter：</strong>很明显这个就是用来处理字符串到字符流的，偶尔会用。</p>
<p><strong>PrintWriter：</strong>该类可用来创建一个文件并向<strong>文本文件</strong>写入数据。可以理解为java中的文件输出，那么它和FileWriter有什么区别呢？PrintWriter可以提供格式化的输出，也就是我们常用的print()函数。其实InputStream中也有和这个类似的PrintStream但是不太常用，上面就没有写出来。</p>
<p><strong>CharArrayWriter和CharArrayReader：</strong>很明显这个是针对字符数组来设计的读写字符流，不在赘述了。</p>
<p>讲完这些单品之后，再来看看Writer和Reader有哪些常用的装饰：</p>
<p><strong>BufferedWriter和BufferedReader：</strong>和Input中的Buffered IO流相同，这个非常重要，几乎读取的时候都要用到。</p>
<p><strong>PushbackReader：</strong>同PushbackInputStream</p>
<p><strong>LineNumberReader：</strong>看名字就知道，这个类是用来统计行数的，用的不是很多，大家需要的时候再细致学习就行了。</p>
<h2 id="字节流和字符流转换"><a href="#字节流和字符流转换" class="headerlink" title="字节流和字符流转换"></a>字节流和字符流转换</h2><p>Java提供了两种流的相互转换的工具：</p>
<p><strong>InputStreamReader：</strong>它将输入字节流转变为输入字符流</p>
<p><strong>OutStreamWriter：</strong>它将输入字节流转变为输入字符流</p>
<p>至于字符流转换为字节流还没有提供，因为字符流本身就很方便了，很多情况下没有必要再转换为字节流。</p>
<p>而且，前面讲过字节流是一个一个字节读的，中文一个汉字可能占用两到三个字节，读字读一半可不是读到的偏旁部首，那完全是另一个字了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了：</p>
<ol>
<li>IO框架存在的意义</li>
<li>装饰模式</li>
<li>字节流和它的小弟，以及小弟的武器们</li>
<li>字符流和它的小弟，以及小弟的武器们</li>
<li>字节流和字符流的转换</li>
</ol>
<p>你看IO的知识并不是很复杂，所以初学者完全没有必要害怕。当然，能否轻松的掌握这个框架的知识，完全在于你的面向对象功底是否扎实，如果你学起来仍旧感觉很吃力，推荐你去翻看设计模式的相关知识，本文中的装饰模式只是简单的举例介绍。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL冲冲冲：MySQL的EXPLAIN关键字和优化</title>
    <url>/MySQL%E5%86%B2%E5%86%B2%E5%86%B2%EF%BC%9AMySQL%E7%9A%84EXPLAIN%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> MySQL针对SQL的执行情况给出了一个强大好用的工具：explain。它可以针对SELECT语句进行分析，并且输出SELECT语句的详细信息，以提供开发人员对SQL的优化，这篇博客就来教大家如何优化自己的SQL语句。</p>
<a id="more"></a>

<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>我们需要创建一个百万数据级别的数据库，否则没有办法展示我们的性能优化在哪里。</p>
<p>这里教大家如何快速的创建一个百万级别乃至千万级别的表，以下在Linux环境中执行，别忘了创建数据库并且选择数据库。</p>
<ol>
<li><p>创建一个临时表：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tmp_table (</span><br><span class="line">    id INT,</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用python把数据写入到文本文件中</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">"for i in range(1, 1+1000000): print(i)"</span> &gt; /tmp/base.txt</span><br></pre></td></tr></table></figure>

<p> pyhton还是很快的，一秒钟不到就搞定百万级别的输出，使用tail命令查看，千万别使用cat！博主手贱使用cat，卡了一分钟。输出完成之后对这个文件进行权限设置</p>
<blockquote>
<p>chmod 777 base.txt</p>
</blockquote>
</li>
<li><p>使用LOAD命令加载数据进</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data infile &#39;&#x2F;tmp&#x2F;base.txt&#39; replace into table tmp_table;</span><br></pre></td></tr></table></figure>

<p> 这时可能会报错</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726114727634.png" alt="image-20200726114727634"></p>
<p> 原因是我们没有打开权限，需要我们在mysql的配置文件中添加 secure_file_priv = /tmp/ ,然后重启mysql</p>
<p> 重新执行：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726115102320.png" alt="image-20200726115102320"></p>
<p> 我的配置是志强E5-2682，只用了6秒就加载完成了。</p>
</li>
<li><p>再创建一个真正要用到的数据表</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_user&#96; (</span><br><span class="line"> &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line"> &#96;c_user_id&#96; varchar(36) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line"> &#96;c_name&#96; varchar(22) NOT NULL DEFAULT &#39;&#39;,</span><br><span class="line"> &#96;c_province_id&#96; int(11) NOT NULL,</span><br><span class="line"> &#96;c_city_id&#96; int(11) NOT NULL,</span><br><span class="line"> &#96;create_time&#96; datetime NOT NULL,</span><br><span class="line"> PRIMARY KEY (&#96;id&#96;),</span><br><span class="line"> KEY &#96;idx_user_id&#96; (&#96;c_user_id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把临时表中的数据插入到数据表中</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO t_user</span><br><span class="line">  SELECT</span><br><span class="line">  id,</span><br><span class="line">  uuid(),</span><br><span class="line">  CONCAT(&#39;userNickName&#39;, id),</span><br><span class="line">  FLOOR(Rand() * 1000),</span><br><span class="line">  FLOOR(Rand() * 100),</span><br><span class="line">  NOW()</span><br><span class="line">  FROM</span><br><span class="line">  tmp_table;</span><br></pre></td></tr></table></figure>

<p> 经过漫长的等待，大概三十秒左右，提示插入成功。</p>
<p> 查看数据：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726120408611.png" alt="image-20200726120408611"></p>
</li>
<li><p>发现上面的数据随机不太行，我们修改一下时间，让时间更随机一点</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) year);</span><br><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) month);</span><br><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) day);</span><br><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) hour);</span><br><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) minute);</span><br><span class="line">UPDATE t_user SET create_time&#x3D;date_add(create_time, interval FLOOR(1 - (RAND() * 7)) second);</span><br><span class="line"></span><br><span class="line">UPDATE t_user SET c_user_id&#x3D;MD5(id+FLOOR(RAND() * 999999));</span><br></pre></td></tr></table></figure>

<p> 又是漫长的等待，大概需要五分钟左右，接下来就是完全随机的时间和uuid啦！</p>
</li>
<li><p>至此，这个表创建完成。来查看一下效果：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726121659390.png" alt="image-20200726121659390"></p>
<p> 为了保持数据的完整性，再创建一个省份表：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_prov( </span><br><span class="line">    &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT, </span><br><span class="line">    &#96;c_prov_id&#96; varchar(36) NOT NULL DEFAULT &#39;&#39;, </span><br><span class="line">    &#96;c_prov_name&#96; varchar(22) NOT NULL DEFAULT &#39;&#39;,  </span><br><span class="line">    PRIMARY KEY (&#96;id&#96;), </span><br><span class="line">    KEY &#96;idx_prov_id&#96; (&#96;c_prov_id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 按照上面的步骤类比着给t_prov插入1000条数据，大家自行操作，我不再演示了。</p>
</li>
</ol>
<h2 id="EXPLAIN简介"><a href="#EXPLAIN简介" class="headerlink" title="EXPLAIN简介"></a>EXPLAIN简介</h2><p>使用EXPLAIN工具可以模拟优化器执行你的SQL语句，从而知道MySQL如何处理你的SQL语句，用来分析查询语句或者你的表结构的瓶颈。</p>
<p>我们直接上手来看一看EXPLIAIN怎么用，使用方法也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM t_user;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726130103640.png" alt="image-20200726130103640"></p>
<p>是不是很简单呢？</p>
<p>然而这里面包含的信息就很复杂了，这些信息包括了：</p>
<ol>
<li>表的读取顺序</li>
<li>数据读取操作的类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引被使用</li>
<li>表之间的引用情况</li>
<li>每张表有多少行被优化器查询</li>
</ol>
<p>现在是不是脑瓜子嗡嗡的？</p>
<h2 id="EXPLAIN包含的信息"><a href="#EXPLAIN包含的信息" class="headerlink" title="EXPLAIN包含的信息"></a>EXPLAIN包含的信息</h2><p>还是这张图，我把每个字段都详细讲一下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726130103640.png" alt="image-20200726130103640"></p>
<p><strong>id：</strong>SELECT 的执行标识符，MySQL给所有的SELECT分配了一个id，当我们进行嵌套查询的时候，id越大越先执行，id相同则从上到下执行。来一个例子：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *  </span><br><span class="line">FROM &#96;t_user&#96; </span><br><span class="line">WHERE &#96;c_province_id&#96; &#x3D; </span><br><span class="line">(</span><br><span class="line">    SELECT &#96;id&#96; </span><br><span class="line">    FROM &#96;t_prov&#96; </span><br><span class="line">    WHERE &#96;c_prov_name&#96; &#x3D; &#39;provName1&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在前面加上EXPLAIN</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726144201351.png" alt="image-20200726144201351"></p>
<p>我们发现这个id不相同，分别为1和2，那么MySQL会先执行id为2的SELECT再执行id为1的SELECT。</p>
<p><strong>select_type：</strong> 上面的例子我们也看到了，select_type有PRIMARY，SUBQUERY，SIMPLE。除此之外还有UNION、UNION RESULT、DEPENDENT SUBQUERY等等。通过名字我们很容易看出来这些表示的什么。</p>
<p>PRIMARY表示此查询是最外层的查询，相对的SUBQUERY，就是子查询。SIMPLE表示这个查询就是简简单单的普通查询。像UNION就不再赘述了。</p>
<p><strong>table：</strong> 这个表示查询的数据源，也就是我们from后面的东西。</p>
<p>*<em>partitions: *</em> 显示的为分区表命中的分区情况。非分区表该字段为空（null），例子中并没有使用分区，所以会显示null。</p>
<p><strong>type：</strong>这个相当的重要了，要着重说一下这个。type的意思是执行这条SQL语句的类型是什么，这些类型表示了SQL的性能。下面性能由强到弱一次排序：</p>
<ol>
<li><p>system：表中只有一行数据或者空表，但是只能用于Myisam和memory，InnoDB遇到这种会出现ALL或者INDEX。因为我使用的是InnoDB，所以就不演示了，这种类型的性能最好。</p>
</li>
<li><p>const：使用唯一索引或者主键的时候出现的，或者返回记录一定是一行记录的等值where条件时（也就是列值不允许重复），如下：</p>
<blockquote>
<p>EXPLAIN SELECT id FROM t_user where id = 1;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726165340142.png" alt="image-20200726165340142"></p>
</li>
<li><p>eq_ref：在连接多个表的查询中出现，并且连接的外键是另一个表的主键或者唯一索引，并且必须为NOT NULL，如下：</p>
<blockquote>
<p>EXPLAIN SELECT u.* FROM t_user AS u JOIN t_prov AS p ON u.c_province_id = p.id;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726170835508.png" alt="image-20200726170835508"></p>
</li>
<li><p>ref：和eq_ref中类似，也出现在多表连接查询中，针对非唯一或者非主键索引，或者使用了最左前缀规则索引的查询，如下：</p>
<blockquote>
<p> EXPLAIN SELECT p.* FROM t_prov AS p JOIN t_user AS u ON p.c_prov_id = u.c_user_id;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726171457575.png" alt="image-20200726171457575"></p>
<p> 例子中，两个列都没有建立索引，所以查询为ref，而eq_ref中的两个列均有主键索引或唯一索引。</p>
<p> 此外，有时我们使用非唯一索引，且查询结果不一定为一行的时候，也有可能出现ref，如下：</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE c_user_id = ‘f081560a4804af51199749a0088db438’;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726171753232.png" alt="image-20200726171753232"></p>
<p> 注意：这个与实际查询出来的结果无关，MySQL觉得你这一列有可能查出来多个结果，那么就会是ref。</p>
</li>
<li><p>range：看名字就知道，这个适用于index中的范围判断，范围判断包括&gt;、&lt;、IS NULL、&lt;=、&gt;=等等。如下：</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_prov WHERE id &gt;1000;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726172441013.png" alt="image-20200726172441013"></p>
<p> 这个时候唯一索引或者主键索引已经丧失优势了，退化为range。</p>
</li>
<li><p>index：这个代表全索引扫描，经常出现在ORDER BY等，在索引上就可以获得数据的情况。如下：</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user order by id;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726173327415.png" alt="image-20200726173327415"></p>
</li>
<li><p>all：这个全表扫描，完全没有走索引，出现这个不改改SQL就等着用户骂娘吧，当然有时候我们无法避免出现all，例如上面的多表查询，我们可以通过小表驱动大表的方式来增强性能，这个后面再说。</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726174052691.png" alt=""></p>
</li>
</ol>
<p>type就先讲到这里，后面优化的时候我会带大家看几个SQL的优化，在实战中巩固知识。</p>
<p><strong>possible_keys：</strong>有可能用到的索引，一个或者多个。查询时候涉及到的字段如果存在索引，那么就将该索引列出，但是不一定被使用。</p>
<p><strong>keys：</strong>实际用到的索引，上面讲过了possible_keys是可能用到的索引，这个与之搭配使用，这个是该SQL语句实际用到的索引。还记得上节讲的索引失效的问题吗？这两个字段搭配起来就可以实现检测索引是否失效的问题。</p>
<p>这里再放出来索引失效的几种情况，并且给出案例供大家分析：</p>
<ol>
<li><p>使用OR的时候，必须OR两边都有索引，否则索引失效</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id&gt;0 OR c_province_id &gt; ‘0’;</p>
</blockquote>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726182908512.png" alt="image-20200726182908512"></p>
<p> 相对应的，OR两边表达式用到的列都有索引：</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id&gt;0 OR c_province_id = ‘0’;</p>
</blockquote>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726182934137.png" alt="image-20200726182934137"></p>
</li>
<li><p>组合索引没有遵循最左原则的时候，索引会失效。</p>
<p> 这个限于没有建立多列索引，我就不演示了吧……</p>
</li>
<li><p>LIKE以%开头，也就是全文查找，这个时候需要使用全文索引来加快查询速度。</p>
</li>
<li><p>需要类型转换，比如VARCHAR少加了双引号，索引就会失效</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE c_user_id=1;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726194813380.png" alt="image-20200726194813380"></p>
<p> 上面的语句中的1没有使用单引号引起来，所以发生了隐式的类型转换，导致索引失效</p>
<p> 正确写法应该是下面这样，varchar类型一定要用引号括起来</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726194933369.png" alt="image-20200726194933369"></p>
</li>
<li><p>WHERE中索引列参与计算、使用了函数会导致索引失效</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id -1 = 9;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726195838088.png" alt="image-20200726195838088"></p>
<p> 正确写法应该是</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id = 1+9;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726200007299.png" alt="image-20200726200007299"></p>
</li>
<li><p>在索引列上使用 IS NULL 或 IS NOT NULL操作。因为索引不会对空值进行索引，所以这个无法使用索引。</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id IS NOT NULL;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726200105904.png" alt="image-20200726200105904"></p>
<p> 应该使用某值代替NULL，这样不仅可以避免该状况，还能让MySQL减少一次是否为空的判断，正确写法为：</p>
<blockquote>
<p>EXPLAIN SELECT * FROM t_user WHERE id &gt;0 OR id&lt;0;</p>
</blockquote>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726200400601.png" alt="image-20200726200400601"></p>
</li>
<li><p>MySQL觉得全表扫描更快的时候</p>
</li>
</ol>
<p>至此，大部分索引失效的情况我都依次举例列出来了。</p>
<p><strong>key_len：</strong>看名字就知道，索引最大可能的长度，并非实际的长度。如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。</p>
<p>并且，key_len只计算WHERE语句用到的索引，ORDER BY和GROUP BY就算用到索引了也不会计算进去。</p>
<p><strong>ref：</strong> 显示索引的哪一列被使用了，如果是使用的常数等值查询，这里会显示const。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726165340142.png" alt="image-20200726165340142"></p>
<p>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726202743973.png" alt="image-20200726202743973"></p>
<p>如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func。</p>
<p><strong>rows：</strong>MySQL自己估计的这次查找可能需要扫描读取多少行，不是精确值。这个值可以反映SQL语句的性能，理论上这个值越小越好。</p>
<p><strong>filtered：</strong>它显示返回结果的行占需要读到的行(rows列的值)的百分比，这个值不一定准确。</p>
<p><strong>Extra：</strong>显示额外信息，这里包含的信息可多了去了，这里限于篇幅，无法一一讲解，希望大家可以再实际开发中自行查询。</p>
<h2 id="索引优化实例"><a href="#索引优化实例" class="headerlink" title="索引优化实例"></a>索引优化实例</h2><h3 id="单表索引优化"><a href="#单表索引优化" class="headerlink" title="单表索引优化"></a>单表索引优化</h3><p>首先给出一个案例：依旧是t_user表的信息，我们需要找出省份id为10，城市id大于，并且创建时间最新的那个用户的名字。</p>
<p>看到这个我们立刻写出一个SQL语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT u.c_name </span><br><span class="line">FROM t_user AS u </span><br><span class="line">WHERE u.c_province_id &#x3D; 10 </span><br><span class="line">AND c_city_id &gt; 80 </span><br><span class="line">ORDER BY create_time DESC  </span><br><span class="line">LIMIT 1</span><br></pre></td></tr></table></figure>

<p>功能已经完成了，查询结果为：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726212240170.png" alt="image-20200726212240170"></p>
<p>可以看到我们查询所花费的时间为0.5秒，这个对于用户来说还是可以接受的。然而，这仅仅只是查询的时间，还会有数据传输、DNS解析、服务器计算、请求等待、锁。这么多步骤哪个不需要时间，这还是百万级别的数据表，千万级别更加可怕。</p>
<p>使用EXPLAIN查看SQL的执行情况：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726212638263.png" alt="image-20200726212638263"></p>
<p>请看红圈圈出来的地方，一个全表扫描，一个使用了文件排序，这两个是最耗费时间的。首先我们解决全表扫描的问题，那就是添加索引。</p>
<p>索引怎么添加呢？既然是三列都被WHERE和ORDER BY使用，那么当然是使用符合索引了，按照最左原则，我们需要根据这个SQL从左到右建立索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user ADD INDEX idx_p_c_t (c_province_id,c_city_id,create_time);</span><br></pre></td></tr></table></figure>

<p>等待几秒，索引建立完成，使用命令查看</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726213336359.png" alt="image-20200726213336359"></p>
<p>现在执行效率如何呢？再次执行。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726213434167.png" alt="image-20200726213434167"></p>
<p>发现全表扫描没了，但是文件排序还是没有解决。</p>
<p>我们来分析一下为什么，我们都知道ORDER BY会最后执行，前面有一个<code>c_city_id &gt; 80</code>范围查找，这个查找打乱了原有的排序，所以ORDER BY无法使用索引排序，也就是索引失效，ORDER BY只能重新进行排序。</p>
<p>因此，我们需要修改原有的索引，将c_city_id列的索引删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user DROP INDEX idx_p_c_t;</span><br></pre></td></tr></table></figure>

<p>重新添加索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user ADD INDEX idx_p_c_t (c_province_id,create_time);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726214226747.png" alt="image-20200726214226747"></p>
<p>发现不仅range变成了ref（没有范围性判断，当然就是ref了），更让人惊喜的还有Extra中出现了Backward index scan。这个是MySQL 8.0之后出现的新的优化机制，当他发现数据好像在索引尾部的时候，不会从头向尾扫描，而是直接从尾拿取数据。</p>
<p>执行时间也接近秒查，可见这次优化是非常成功的。</p>
<h3 id="双表索引优化"><a href="#双表索引优化" class="headerlink" title="双表索引优化"></a>双表索引优化</h3><p>双表中我们会使用左外连接和右外连接的方式来进行。</p>
<p>我们仍旧使用上面的两个表作为示范使用，给出一个案例，要求查找省份唯一标识和用户唯一标识相等的省份名（UUID理论上是不可能重复的，可是我使用的是MD5伪UUID，你可以类比为两个没有索引的键）。</p>
<p>开始案例之前先把原有的索引删除，删成下图这样就可以了。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726224002148.png" alt="image-20200726224002148"></p>
<p>相信大家很快就能写出来一个SQL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT p.c_prov_name FROM t_prov AS p JOIN t_user AS u ON p.c_prov_id &#x3D; u.c_user_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726225236401.png" alt="image-20200726225236401"></p>
<p>发现连个都是全表扫描，后面的预测扫描行数更是接近全表行数，如果没有后面的Using join buffer执行起来还真不一定多少时间呢。</p>
<p>全表扫描当然要开始优化了，我们按照顺序先对左表添加索引吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_prov ADD INDEX idx_prov_id (c_prov_id);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726225642292.png" alt="image-20200726225642292"></p>
<p>我们发现左边的表执行类型变为了ref，并且rows也变成了1。也就是表t_prov的优化很成功。然而，u表是一个百万级数据的表，依旧是全表扫描的执行类型，之前的优化仍然是杯水车薪。我们再给右边的user表加索引试试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE t_user ADD INDEX idx_user_id (c_user_id);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726230112760.png" alt="image-20200726230112760"></p>
<p>我们很惊奇的看到了，prov的索引失效了，而user表的索引成功优化。这是为什么呢？</p>
<p>这个和左外连接的特性有关，左外连接是对右表进行筛选限制，而左表的所有数据都在。所以左表总是全表扫描，添加索引也没有用处。所以我们在连接过程中，需要将数据量小的表作为主表，驱动数据量大的表作为副表，并且给数据量大的表建立索引，这种方式叫做小表驱动大表。</p>
<p>至于为什么之前的左连接prov表索引还能生效，完全是MySQL自己帮你调整了连接方式，自动帮你优化了SQL。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了：</p>
<ol>
<li>EXPLAIN总结</li>
<li>EXPLAIN包含的信息什么含义</li>
<li>索引失效的实际案例</li>
<li>索引优化的实际案例</li>
</ol>
<p>看标题内容挺少的，然而更多的知识潜藏在我们日常开发实战中，最后再送大家两个口诀。</p>
<p><strong>索引失效：</strong></p>
<ol>
<li>全值匹配最喜欢，最左前缀规矩严。</li>
<li>带头大哥不能死，中间兄弟不能断。</li>
<li>索引列上少计算，范围之后全完蛋。</li>
<li>LiKE百分最右边，覆盖星号讨人嫌。</li>
<li>不等空值还有OR，你建索引也失效。</li>
<li>VAR引号要出现，SQL高级也不难。</li>
</ol>
<p><strong>索引口诀：</strong></p>
<ol>
<li>主键索引自动建，频繁查找索引现。</li>
<li>查询关联其他表，外键索引也要看。</li>
<li>频繁更新不适合，WHERE不建没法办。</li>
<li>单建组合选择难，高并发下组合建。</li>
<li>若要速度有体现，排序字段你得建。</li>
<li>统计分组你咋看？索引索引建建建。</li>
</ol>
<p>睡觉啦，晚安。口诀看不懂，记得联系我哦。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>EXPLAIN</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL冲冲冲：MySQL索引的从认识到实战</title>
    <url>/MySQL%E5%86%B2%E5%86%B2%E5%86%B2%EF%BC%9AMySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%8E%E8%AE%A4%E8%AF%86%E5%88%B0%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p><strong>INTRO：</strong>MySQL是我们常用的关系型数据库，小巧灵活。在开发过程中，当我们的数据量超过一定程度的时候，就需要我们使用索引来优化查询和排序的速度，这篇文章就来尽量全面的讲一讲索引。</p>
<a id="more"></a>

<h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><p> MySQL官方给索引一个定义——帮助MySQL高效获取数据的数据结构。注意，这里得到了一个关键字，索引是一种数据结构，一种帮助我们更快速获取数据的数据结构。</p>
<p>我们初学MySQL时并没有使用索引，查找数据需要全表扫描，也就是从第一行开始扫描，直到最后一行。如果我们表里数据非常大，上千万行的数据，全表扫面会特别慢，这个时候如果有一个“目录”来帮助我们快速定位数据就好了。</p>
<p>这个时候就出现了索引，我们可以把索引对比成新华字典的目录，目录是不是一种独特的数据结构呢？目录由拼音+页数组成，通过对应拼音的页数我们可以快速找到想要的数据。如果没有目录，我们需要从a开始，一个字一个字的对比（MySQL这本字典可不是按规律排的），直到找到我们想查的字，如果想查a还好，想查zhouxx可咋整。</p>
<p>通过这些描述我们知道了，WHERE条件后面需要查找的关键字可以使用索引。还有什么可以使用索引优化呢？索引还有一个别名：排好序的快速查找数据结构。所以我们在ORDER BY中也可以使用索引来优化结果。</p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>上面讲过了索引是一种数据结构，所以索引是什么样的数据结构呢？     </p>
<p>先说结果：索引是一种排序树，这里有同学就开始疑惑了，排序树是个嘛玩意？</p>
<h3 id="排序树是啥？"><a href="#排序树是啥？" class="headerlink" title="排序树是啥？"></a>排序树是啥？</h3><p>排序树又称搜索树、查找树。看名字就知道这个和索引高度相似，索引是干嘛的？一种排好序的快速查找数据结构。这两个东西就对应起来了，那么我们只要学好了这个什么排序树就能更加接近MySQL索引的底层原理了。</p>
<p>讲排序树之前需要大家知道一些储备知识：树的数据结构特点、二叉树的相关知识。</p>
<p>排序树的叉不确定，本文就按照最简单的二叉排序树来讲，核心知识都是相同的，多叉排序树大家自己类比就好。</p>
<p>先说二叉排序树的定义：</p>
<ol>
<li>若左子树不为空，则左子树所有结点的值均小于该结点的值</li>
<li>若右子树不为空，则右子树所有结点的值均小于该结点的值</li>
<li>任意结点的左右子树也是二叉排序树</li>
<li>没有键值相等的结点</li>
</ol>
<p>是不是读起来很绕口？</p>
<p>我们来看一个例子：</p>
<p>有一串数字——8 6 5 4 7 2 3 1 9，我们怎么生成一个二叉搜索树呢？</p>
<p>首先取出数字8作为根结点，随后下一个数字为6，比8小，所以我们把6作为8的左结点</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725105612632.png" alt="image-20200725105612632"></p>
<p>再取出一个数字5，比8小，可是8已经有左子结点了，再对比8的左子结点6，比6小，所以我们把数字5放在6的左子结点。同理数字4也是一样，现在树变成了这样：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725105533427.png" alt="image-20200725105533427"></p>
<p>这时来了一个不素之客7，比8小，又比6大，那么我们就把它放到6的右子结点：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725105514803.png" alt="image-20200725105514803"></p>
<p>按照这种从根结点逐步向下扩展，并且遵循小的放左边、大的放右边这个规律，最终生成的树就是二叉搜索树。</p>
<p>例子中最终生成树为：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725105359707.png" alt="image-20200725105359707"></p>
<p>好吧，例子举得不好，这个树太丑了……数字是我随便敲的，长成这样我也没办法……</p>
<p>那重新来一个例子吧，例子二：</p>
<p>5 6 3 4 7 1 9 2 8</p>
<p>生成树为：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725110331135.png" alt="image-20200725110331135"></p>
<p>这个树就好看多了……</p>
<p>那么这个树有什么作用呢？或者说为什么叫做查找树呢？</p>
<p>我们使用第二个例子，假设需要查找数字2，从根结点查找开始，比5小，那么我们右边的树（因为排序树右边的都比根结点大）就不看了，只看左边的子树。查找到3，比3小，右边不看。查找到1，比1大，左边不看（虽然左边没结点了），只看右边，查找到2，完成查找。</p>
<p>一共查找了4次，如果不使用二叉查找树呢？我们需要查找7次。</p>
<p>有同学说了，你这不对，看似查找很少，其实你有一段时间浪费在生成二叉树上了。没错，这就是索引的弊端了，索引需要在修改数据的时候额外付出一点代价，但是这个代价是值得的。</p>
<p>上面的也看到了，有的二叉查找树可能严重偏枝，也就是聚集在左子树或者右子树，排序树退化成一个链表，这样我们查找起来时间复杂度还是O(n)（如果根结点是最大值，我们需要查找最小值）。</p>
<p>也就是9 8 7 6 5 4 3 2 1 这一串数字生成的二叉查找树。</p>
<p>于是为了解决该问题，大佬们又设计了一个新的树形数据结构：B树，也叫做平衡树。</p>
<h3 id="平衡树又是啥？"><a href="#平衡树又是啥？" class="headerlink" title="平衡树又是啥？"></a>平衡树又是啥？</h3><p>平衡树具有一下特性：</p>
<ol>
<li>具有查找树的所有特性</li>
<li>每个结点的左子树和右子树高度差小于等于1</li>
</ol>
<p>这两个特性使得二叉平衡树的查找的时间复杂度总能保持最坏情况下为O(log n)，实现二叉平衡树的算法也有很多：AVL、红黑树、Treap等等，希望大家自行查询学习。</p>
<p><strong>B树：</strong>B树属于平衡树的一种，又称为平衡多路查找树。我们来认识一下B树，《算法导论》中是这样写的B树是为磁盘或其他存取的辅助存储设备而设计的一种平衡搜索树，类似于红黑树，但是在降低磁盘I/O的操作树方面更好一点，许多数据库系统使用B树或者B树的变种来存储信息。</p>
<p>《算法导论》中给出了B树的精确定义：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725161016276.png" alt="image-20200725161016276"></p>
<p>看起来是不是挺复杂的，简单来说就是一个结点不止存放一个值，这些值以升序排列（这里翻译真是绝了，非降序……），每个结点都有该结点存储的关键字数+1个子结点，这些子结点中也存储数据，并且不同的子结点存放不同范围的数据，该范围由双亲所存储的值决定。</p>
<p>怎么构建B树请大家自行查询，因为不画图听不太明白，画图我又太懒……</p>
<p>给大家推荐一个讲解的比较明白的博客<a href="https://www.jianshu.com/p/cf7dba86c391" target="_blank" rel="noopener">数据结构之B树与B+树</a></p>
<p>上面讲的是B树，而<strong>MySQL中两个数据引擎默认都是使用的B+树作为索引</strong>。</p>
<p>B+树和B树有什么不同呢？B+树是B树的进阶版本，两者有何不同呢？</p>
<p>我们看到定义中B树是每个结点都存放多个数据，B+树不同，B+树只有叶子结点存放数据，并且任何非叶子结点都会在叶结点上再次出现一次，更加丧心病狂的是把所有叶子结点从左到右链接了起来（所有叶子结点自成链表），所以我们扫描的时候只需要从第一个叶子扫描到最后一个叶子结点就行了，显然这种更适合数据库索引。</p>
<p>除此之外，B树的查找性能不稳定，有可能在第一个结点就查找到了，也有可能</p>
<p>来一张B+树的图：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725205902444.png" alt="image-20200725205902444"></p>
<p>总结一下奇葩的B+树特点：</p>
<ol>
<li>父结点存放的元素都在子结点重复出现，因为此特性，叶子结点就包含了整个树的所有元素</li>
<li>叶子结点从左到右依次链接，形成一个有序链表</li>
</ol>
<h2 id="B-树查找演示"><a href="#B-树查找演示" class="headerlink" title="B+树查找演示"></a>B+树查找演示</h2><p>上面简单讲了B+树的特性，回想一下我们对MySQL中索引的概况——排好序的快速查找数据结构。</p>
<p>我们来演示一下B+树怎么快速的查找：</p>
<p>假设我们查找数据：3</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200725205902444.png" alt="image-20200725205902444"></p>
<p>从根结点开始，3&lt;8，我们要查找的数据在最左子树，也就是258所在的结点。3&gt;2并且3&lt;5，我们要查找的数据在中间结点，也就是3,5所在的结点，随后成功找到3。</p>
<p>有同学要问了，如果我查找的数字是5呢？5可是在258中出现过的数字，我怎么知道是在中间结点还是最右结点呢？同学们，你们有没有发现B+树父结点的数字会被继承给子结点，并且继承过来的数字对于子结点来说都是最大的值。当然不一定每个B+树都是继承最大的值，也可以是最小结点。所以查找的元素在非叶子结点的时候需要我们查找该值左边的子树。</p>
<p>接下来给大家演示一个神奇的操作，区间查找。</p>
<p>假如我们需要查找一个区间的值：6~11</p>
<p>我们会先查找6，然后按照叶子结点之间的链表，往下遍历到13（不确定有没有多个11，遍历到13停止）。</p>
<p>相对于B树来说，B+树作为数据库索引真是太好用了。</p>
<h2 id="索引实战"><a href="#索引实战" class="headerlink" title="索引实战"></a>索引实战</h2><p>讲了那么多理论知识，终于到实战了。、</p>
<p>建表之后创建索引使用命令：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX index_name ON my_table(column_name);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE my_table ADD [UNIQUE] INDEX index_name(column_name);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>建表的时候使用命令：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable(  </span><br><span class="line">    ID INT NOT NULL,   </span><br><span class="line">    username VARCHAR(16) NOT NULL,  </span><br><span class="line">    INDEX [indexName] (username(length))  </span><br><span class="line">); </span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们需要注意两个事情：</p>
<ol>
<li>创建索引需要占用额外的空间，请保持磁盘空间充足</li>
<li>创建索引会对全表加锁，请在业务空闲时间创建，最好在程序规划的情况下创建</li>
</ol>
<p>删除索引：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP INDEX my_index ON tablename；</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>查看索引：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM my_table;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="什么时候该用索引"><a href="#什么时候该用索引" class="headerlink" title="什么时候该用索引"></a>什么时候该用索引</h3><p>上面我们学习过了，索引需要额外的插入时间，但是可以大幅度减缓我们的查询和排序时间。</p>
<p>由此我们可以得知，在频繁读取的业务表上增加索引，对频繁作为限定条件的列增加索引。除此之外，还有一些建立索引的建议：</p>
<ol>
<li>主键自动建立唯一索引</li>
<li>WHERE和ORDER BY经常用到的列增加索引</li>
<li>高并发情况下建立索引</li>
<li>经常用于聚合函数的列建立索引</li>
</ol>
<p>对几乎不读或者少读的表、修改增加删除频繁的表酌情考虑不加索引。总结如下：</p>
<ol>
<li>经常修改删除的不建立索引</li>
<li>有大量重复列的不建立索引</li>
<li>表记录太少的不建立索引，不到1000索引无关紧要</li>
</ol>
<h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><p>常见的索引类型有：</p>
<p><strong>主键索引：</strong>该索引建立在主键上，称为主索引，不允许空值、不允许重复。注意，这个索引是自动建立的。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>唯一索引：</strong> 建立索引的列不允许重复值，但是可以为空</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>普通索引：</strong>看名字就知道，没有任何限制的普通索引</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>全文索引：</strong>使用大文本对象的列需要用到的索引</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;)；</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>组合索引：</strong>利用多个列进行组合构建的索引，列中不允许有空值</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;)；</span><br></pre></td></tr></table></figure>
</blockquote>
<p>值得注意的是组合索引，其遵循最左原则，也就是我们创建的这个索引不是col1、col2、col3随便都能使用的，这个索引只有查询为col1、col1+col2、col1+col2+col3才能使用，而像col2+col1就不能使用，一定要记住查询的顺序。</p>
<p>并且，使用组合索引的时候可能导致因为列名太长而导致索引的key太大，影响性能，在允许的情况下使用col1(n)来取列名的前n个字符。</p>
<h3 id="索引失效！"><a href="#索引失效！" class="headerlink" title="索引失效！?"></a>索引失效！?</h3><p>没错，你建立了索引不是就万事大吉了，很有可能你写的SQL不规范导致你的索引失效，也就是白建立索引了。</p>
<p>有以下几种情况需要注意：</p>
<ol>
<li><p>使用OR的时候，必须OR两边都有索引，否则索引失效</p>
</li>
<li><p>组合索引没有遵循最左原则的时候，索引会失效。</p>
</li>
<li><p>LIKE以%开头，也就是全文查找，这个时候需要使用全文索引来加快查询速度。</p>
</li>
<li><p>需要类型转换，比如VARCHAR少加了双引号，索引就会失效</p>
</li>
<li><p>WHERE中索引列有计算、使用了函数会导致索引失效</p>
</li>
<li><p>在索引列上使用 IS NULL 或 IS NOT NULL操作。因为索引不会对空值进行索引，所以这个无法使用索引。</p>
</li>
<li><p>索引列使用不等于无法使用索引，所以key&lt;&gt;x可以改为key&gt;x OR key&lt;x</p>
</li>
<li><p>MySQL觉得全表扫描更快的时候</p>
</li>
</ol>
<p>这里放一张官方的图，关于索引失效的案例可以看我下一篇博客。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200726000540016.png" alt="image-20200726000540016"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇博客讲了什么：</p>
<ol>
<li>什么是索引？为什么要有索引？</li>
<li>从二叉排序树到B树再到B+树</li>
<li>MySQL索引的原理是什么？</li>
<li>B+树怎么查找范围和单行</li>
<li>索引的使用环境</li>
<li>MySQL有哪些索引</li>
<li>索引失效的场景</li>
</ol>
<p>这两天身体有点不舒服，博客写的质量肯定不如从前。过段时间要去上海找工作了，在家沉淀蛮久了。MySQL的相关知识还是继续更下去，再更个两篇就准备去上海了，祝我好运。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
