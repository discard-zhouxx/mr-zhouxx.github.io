<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>白话Spring（一）：SpringIOC到底是个啥？</title>
    <url>/%E7%99%BD%E8%AF%9DSpring%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringIOC%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>INTRO:</strong> 学习过Spring框架的人一定都听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，这两个概念还是比较难懂的，所以博主就用大白话的给初学者讲一下这两个概念。</p>
<a id="more"></a>

<p>开门见山，我们先来一个没有IOC的程序例子：</p>
<p>Dao层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserFrominfo</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    	<span class="comment">//操作数据库代码</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Service层代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UserDao userDao)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.UserDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userDao.selectUserFrominfo(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Controller层代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    UserServiceimpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserService userService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = UserService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        userService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    UserController userController;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringp[] args)</span></span>&#123;</span><br><span class="line">        UserDAO dao = <span class="keyword">new</span> UserDAO();</span><br><span class="line">        UserService service = <span class="keyword">new</span> UserService(dao);</span><br><span class="line">        UserController controller = <span class="keyword">new</span> UserController(service);</span><br><span class="line">        controller.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能有的同学要问，这不是挺好的吗？new一下可以实例化，也没浪费多大功夫嘛。</p>
<p>在此回答此问题之前，我们需要了解一个软件工程上的知识点：</p>
<p><strong>耦合度：</strong> 程序之间的依赖关系。我们可以通俗的讲依赖关系就是没有你，我办不成事。人越独立越好，模块也不例外，但是人又不可能完全独立于社会，就像模块不可能完全脱离系统，而消除这种依赖关系的过程就是解耦。</p>
<p>再来看上面的代码，有哪些弊端呢？</p>
<ol>
<li>创建繁琐，每一层我们都需要创建下一层的对象，这个我们能忍，毕竟我们是勤劳勇敢的中国人民，麻烦点不算什么，下面的就不好搞了。</li>
<li>违反面向接口编程的原则，每一层都直接new一个对象，后期更换接口需要工作量爆表。</li>
<li>在这一串调用链中，上层知道下层是如何创建的，上层还需要自己动手创建下层。就好比没有人力资源管理的公司，任何人事的调动都需要该职员的上司进行处理，上下层的耦合性飙升。</li>
<li>开发人员不能专心编写业务逻辑，编写业务逻辑代码时还需要自己连接数据库+自己创建Dao+记住数据库密码。</li>
</ol>
<p>如果使用IOC呢？彻底推翻上述的所有弊端，唯一的缺点就是增加那么一丢丢的学习成本，以及添加那么”亿”丢丢的配置文件。当然这两个缺点第一个是值得的，第二个则被SpringBoot给摆平了。</p>
<p>简单了解IOC有什么用之后，我们再来看IOC到底什么意思。</p>
<p><strong>IOC——控制反转：</strong>有反就有正，所谓的正就是我们在程序中new一个对象出来，我们就开始控制这个对象的生命周期，反转之后呢？<del>这个对象开始控制我们的生命周期</del>（删）我们将对象生命控制权交给Spring，由Spring给我们new对象出来。Spring在这个过程中扮演的就是一个人力资源管理部门的角色，作为大老板的我们应该将精力放到业务逻辑上。 而这些被管理的职员，我们通常称之为Bean。Bean又是什么呢？为什么名字这么奇怪？</p>
<p>Bean这个词并非起源于Spring，只是最近二十年开发者大多都是从Spring中接触到Bean这一名词，Bean的起源年代久远，当初Java还抱着幻想反攻桌面端，但是被微软的VB打的满地找牙。当时微软大推模块化，在IDE中通过拖拽就可以给界面添加各种组件。Java开源社区急了，这种好东西我们也要有，于是大家商量着整出一套规范——JavaBean。通过这个规范就可以让IDE根据反射快速的构建界面，然而没人买账……现在回答Java Bean是什么？Java Bean是一种规范，而Bean就是遵从这个规范的类。你要是问为什么叫Bean而不叫其他什么，那就只能说Java Bean合在一起叫做咖啡豆，起这个名字的人觉得好玩。</p>
<p><strong>Java Bean规范了什么？</strong> 上面说了JavaBean是一种规范，那么规范了什么呢？主要规范了以下四点：</p>
<ol>
<li><p>所有属性使用private</p>
</li>
<li><p>给private标记的属性添加getter/setter方法</p>
</li>
<li><p>实现序列化</p>
</li>
<li><p>具有默认的构造函数（无参的构造函数） </p>
</li>
</ol>
<p>控制反转和我们平常使用的Maven很像，没有Maven的时候，我们需要将所需的依赖包一个个下载好，放到lib文件夹中。有了Maven之后，我们只需要在配置文件中配置上该App所需的所有依赖包，是不是很方便？假如我们需要更换依赖版本，只需要在pom.xml文件中修改版本号，Maven就会自动给我们导入依赖包。相对应的，我们需要更改某一接口的实现类的时候只需要修改注释/配置文件就可以了。</p>
<p>那么怎么告诉Spring这些依赖关系呢？我们可以通过注释或者xml配置文件的方式。</p>
<p><strong>注解方式的IOC：</strong>IOC相关的注解很多，但是总体可以分为两类组件注册和组件加载。</p>
<p>组件注册注解是由@Component注解及其一堆小弟组成的，像业务层的@Service、控制层的@Controller、数据操作层的@Repository。这些小弟可以被@Component代替，但是还是推荐层次更明确的小弟注解。这些注解的作用是告诉Spring哪些类需要你控制，Spring把这些类变成Bean实例，这些实例的名字使用变量类似的驼峰命名法，也就是将类的首字母变为小写，其他不变。注册Bean的过程也就是告诉人力资源部门哪些人是我们公司的职员。当然Spring不知道从哪里找这些组件，你需要在配置文件中配置Spring扫描哪些包。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	首先通过context命名空间引入component-scan配置</span></span><br><span class="line"><span class="comment">	component： 组件</span></span><br><span class="line"><span class="comment">	scan： 扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.exmples.*"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样Spring道了哪些包中的组件需要自己管理，又知道这些包中的类需要注册为什么类型。但是这些组件注册之后安排到什么岗位呢？那么就要用到组件加载相关的注解了。</p>
<p>组件加载常用的有@Autowired，@Resource、@Qualifier。@Autowired是Spring中主要使用的注解，它可以通过成员变量/成员变量的setter方法/构造函数将依赖注入。这三个注解有什么区别呢？@Autowired和@Qualifier是Spring中自带的，而@Resource则是在javax.annotation包中。另外@Resource默认是通过名称加载，如果名字找不到，那么就通过类型注入。@Autowired则仅支持通过类型加载的，@Autowired可以和@Qualifier结合使用，可以通过类型和名称双限定加载。至于@Qualifier注解，它一般不单独使用。</p>
<p>我们常用的方式就是@Autowired注解，所以@Resource注解的方式不再演示了。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"dependency"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="comment">//balabala</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calss Exmple&#123;</span><br><span class="line">    <span class="comment">//通过成员变量注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"dependency"</span>)</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exmple</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过setter方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">      	<span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上三种注入方法，选择其一即可。这里提一句，不推荐使用成员变量直接注解的方式，而setter和构造方法各有优缺。下面聊聊这三种方式：</p>
<p><strong>字段注入：</strong>又叫属性注入、field注入等等，这种方式代码简洁，编写方便，但是有很多缺点，缺点如下：</p>
<ol>
<li><p>在声明为 final 的字段上不可用，因为final修饰的关键字需要在类实例化的时候进行初始化，这种字段只能使用构造器注入。</p>
</li>
<li><p>与SpringIOC组件耦合，这种方式需要Spring通过反射将属性注入，除此之外没有任何办法（不嫌麻烦你可以使用反射，因为Spring也是这么干的）给这个属性赋值，在你进行单元测试的时候你还要呼叫Spring过来帮你初始化这个依赖，多麻烦呀。就好像你想找小a倒杯水，明明小a就在你隔壁，却还要让人力资源部门通知小a倒水。</p>
</li>
<li><p>隐藏依赖关系，字段注入的方式很简单，一个注解就搞定了。但是简单到让人忘记你到底有多少个依赖，让接手的人不知道哪个才是你的依赖。比如你在公司看到一个不干活的职员，你找人力资源部门说 “这小子哪个部门的？给我开了他！” 结果人力资源部门跟你说，这哥们送外卖的。 </p>
</li>
</ol>
<p><strong>setter方法注入：</strong>这种方式有利有弊，我在小项目开发中一般使用这种方式，因为可以把setter方法藏到最后，代码看起来没那么臃肿。setter唯一的不足就是不能给final依赖注入，但是解决了字段注入的两个缺陷：</p>
<ol>
<li>解除SpringIOC组件的强耦合关系，依赖不仅可以使用Spring注入，也可以通过调用setter方法的方式注入依赖。 </li>
<li>显示依赖关系，通过setter方法上的注释，我们可以知道这个类的依赖关系有哪些，哪些依赖关系需要Spring帮助我i们注入。</li>
</ol>
<p><strong>构造方法注入：</strong>这种注入依赖的方式是Spring官方指定推荐，也就是皇太子（虽然setter注入方式在Spring 3.x 中也是被推荐的那一位）。这种方式几乎没有任何缺点，唯一的缺点就是当你的依赖关系很多的时候，你的构造方法看起来不太美观。碰到这种情况，你就要考虑自己程序设计的是不是有问题了，是不是违背了单一职责原则（如果有机会就把设计原则讲一下，下次一定）呢？细数起来构造方法注入的方式优点如下：</p>
<ol>
<li>允许final关键字修饰的依赖注入，这个没得说，只有这位皇太子有这本事。</li>
<li>依赖检查，重写了有参的构造函数，想实例化这个类就只能通过有参的构造函数完成初始化，万一有个依赖注入失败，那这个类就无法初始化。就好比开会的时候，Spring会告诉你某某某开会没来，这个会开不成，而不是像字段注入和setter方法注入中，让某某某干活了，某某某说我没开会（注入依赖） ，我空指针了。</li>
</ol>
<p>那么构造器注入的方式相较setter方法注入有什么不足呢？setter方法允许类构建之后重新注入。</p>
<p><strong>总结来说：</strong> setter和构造方法各有优劣，每个都有自己不可替代的功能，相较于两位皇子来说，字段注入是不受宠的那个。在实际开发中还是推荐使用构造方法注入的方式。</p>
<p><strong>XML配置文件的注入方式</strong> 讲完注解的方式注入依赖，来看一看开发环境中不是很常用的xml配置文件注入的的方式。XML有两种注入方式，构造器注入和setter方法注入，这两者的优劣类似于注解中两种方式的优劣。</p>
<p>首先来看构造器注入的配置，写在applicationContext.xml中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Denpendency</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中展示了Spring如何创建一个dependency示例并将该实例注入Test中，首先是&lt;bean&gt;标签的讲解，bean标签常用的两个属性id和class，id指定了这个bean在Spring中唯一的标识符，其他bean可以通过id引用该bean，其实相当于java中的标识符（名字！够清楚了吧）。class则指定了这个bean对应的类，也就是告诉Spring哪个类需要注册为id=xxx的bean。这个bean又有哪些属性或者依赖呢？通过&lt;constructor-arg&gt;标签中的两个常用属性value和ref，其中value是没有在Spring中注册的属性（什么是注册请看前面两句刚写的&lt;bean&gt;标签讲解），例如数据库密码、数据库驱动url等等。ref则表示在Spring中注册过的依赖，引用该依赖的方式是ref=“id”。</p>
<p>还是人力资源管理部门的例子，value是公司外的资源，例如隔壁老王送水电话，村头小张仓库地址，这些资源不属于公司内部，没有被人力资源管理部门所管理，但是又被某职工所需要，那么在职工入职（注册为Bean）的时候将这些信息传给这个职工。ref又是个怎么回事呢？ref是公司给你安排的小弟，类似于Controller层，作为高层怎么能没有小弟呢？在空降领导的时候总得带着领导见见小弟吧？ref就是这么回事，你告诉Spring这个领导需要哪些小弟，Spring带着这些小弟<del>注入</del>接见领导，当然这些小弟都需要在Spring中注册过了，不然你还是要用value的方式注入依赖。</p>
<p>看完了XML配置+构造器方法注入之后，再来看XML+setter方法的注入方式。</p>
<p>同样是applicationContext中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dependency"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Dependency"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">value</span>=<span class="string">"argValue"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"org.exmple.Test"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">ref</span>=<span class="string">"dependency"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖类Dependency：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类Test：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependency;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependency</span><span class="params">(Dependency dependency)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dependency = dependency;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，与注解的方式不同，在类中必须有setter方法，否则Spring会报错。至于value和ref什么意思，刚讲过就忘啦？？？？</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="# 写在最后"></a># 写在最后</h2><p>到这里，算是用最直白的话把我理解的Spring IOC和使用方式写出来了，因为本人水平限制，这篇文章一定还有纰漏，希望看官能够指点一下。</p>
<p>因为都是用大白话讲解的，所以涉及的知识难免比较浅薄，目的只是为了帮助初学Spring的同学尽快的了解Spring，具体的深入还是需要大家多多实践。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（一）：SpringBoot入门</title>
    <url>/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASpringBoot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> SpringBoot究竟是何方神圣？Spring开发人员使用SpringBoot之后为何热泪盈眶？JavaEE生态圈为何对SpringBoot狂舔不止？这一切的原因究竟是Spring不够骚了，还是你SpringBoot有点飘了？接下来，欢迎收看我的SpringBoot学习笔记之SpringBoot入门，让我们一起走进SpringBoot的内心世界。</p>
<a id="more"></a>

<h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><p>记者：您好，SpringBoot，请问您可以简单介绍下自己吗？</p>
<p>SB（SpringBoot的简称）：大家好，我可以轻松创建一个基……</p>
<p>记者：停，能不能简单通俗点说？</p>
<p>SB：啊，大家好，我是Spring全家桶中的一个成员，我今年六岁啦！</p>
<p>记者突然一把扯掉SB的面具，面具下露出Spring的脸。</p>
<p>记者：哼，果然你就是Spring。</p>
<p>SB：才不是呢！我的底层虽然是Spring，但是我更加简单，比如你们说Spring配置文件一大坨，我就尽量给你们自动配置，你们说项目部署到Servlet容器太麻烦了，我就自己内嵌一个Servlet容器，而且开场白我就说了，我可以轻松的构建一个Spring应用……</p>
<p>记者：这样啊，那你都可以做什么呢？</p>
<p>SB：Spring能干的我全都能干，而且更简单，一站式懂吗？就是那种，有我一个人就够了，不用添加什么乱七八糟的依赖、配置文件。</p>
<p>记者：既然你这么优秀，怎么还没取代Spring全家桶呢？</p>
<p>SB：阿这……因为我毕竟是Spring的一种实现方式，这么简单的我，取代Spring是迟早的事，但是单独一个我并不能做什么惊天动地的大事，只有联合我的Spring全家桶中的兄弟姐妹才能在JavaEE圈中称王称霸，毕竟我在Spring生态圈中人缘最好，和第三方框架关系也不错！至于Spring那个老东西，不会还有公司在用吧？不会吧？不会吧？</p>
<p>记者（面向博主）：博主，你被公司开除了。</p>
<p>博主：现在我来总结一下，SpringBoot是Spring的一个变种，其实本质上还是Spring那一套，它可以做到一站式开发，在开发前简化项目依赖，开发过程中简化配置，开发完成后简化部署。不仅能够和Spring全家桶完美契合，还能和主流第三方框架进行整合。乐观地说，SpringBoot取代Spring只是时间问题，然而，SpringBoot使用了大量的Spring提供的API，如果不学习Spring的话，SpringBoot也就只能停留在比较浅的层面。</p>
<h2 id="整一个HelloWorld"><a href="#整一个HelloWorld" class="headerlink" title="整一个HelloWorld"></a>整一个HelloWorld</h2><p>程序员的老规矩，接触新技术先整Helloworld。博主使用的是Idea（别问博主是不是盗版了，学生可以白嫖！！），步骤会一步一步的贴出来，还搞不定的话……放张图与君共勉。<img src="https://gitee.com/vanbyz/images/raw/master/img/20200627110835.png" alt="20200627110835"></p>
<p>永远有比我们更惨的人，他都能坚持下去，为什么我们不可以呢？</p>
<p>首先开始第一步，打开我们的idea，创建一个Maven新项目（2020了，不会还有人不知道怎么创建Maven新项目吧？不会吧？）</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112301999.png" alt="image-20200627112301999"></p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112538113.png" alt="image-20200627112538113"></p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627112758857.png" alt="image-20200627112758857">    ok，现在项目创建好了。既然是Maven项目，那么肯定要配置pom.xml文件啦。</p>
<p>打开SpringBoot官网提供了快速开始的配置，那是相当方便啊。知道你们懒，我直接贴在下面。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相比SSM框架中导入一大堆依赖来说是不是简单很多？</p>
<p>在main目录下，我们建以下结构，包名自己取，但是欢迎照抄嘿嘿嘿。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627142632994.png" alt="image-20200627142632994"></p>
<p>然后再根据下面的结构创建两个类，根包下的类命名需要注意一下，需要写成${项目名}Application：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627143809642.png" alt="image-20200627143809642"></p>
<p>在SpringBootDemoApplication类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在HelloWorldController类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有小朋友要问了，是不是该配置Tomcat了？SpringBoot不屑一笑，你懂什么叫做可运行吗？</p>
<p>直接运行SpringBootDemoApplication。</p>
<p>看到控制台显示如下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627145252013.png" alt="image-20200627145252013"></p>
<p>这一行中出现了熟悉的字眼——Tomcat，原来SpringBoot自带了一个Tomcat！现在我们去浏览器看一下效果。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627145442925.png" alt="image-20200627145442925"></p>
<p>不用一行配置文件，完成HelloWorld，请所有SSM框架的使用者们全体起立，现在这里是SpringBoot广场！开发狂喜，运维狂喜，前端流下羡慕的口水。</p>
<p>HelloWorldController没什么说的，这是SpringMVC中的内容。</p>
<p>值得我们注意的是SpringBootDemoApplication，该类使用了一个叫做@SpringBootApplication的注解，这个注解告诉SpringBoot，这是主配置类。那么@SpringBootApplication是什么呢？</p>
<p>按住Ctrl，左键单击这个注解查看源代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>发现这是一堆注解的组合，前面四个不再详细说，这四个注解表示创建一个注解时这个注解的属性，它们注解的含义和用法可以参考<a href="https://www.jianshu.com/p/8738ce6bd771" target="_blank" rel="noopener">这篇博客</a> 。既然是组合，那么你也可以将后面的注解替代@SpringBootApplication使用，就变成了下面这样。当然，开发环境中你敢这样玩，那你是个狠人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">        excludeFilters = &#123;<span class="meta">@ComponentScan</span>.Filter(</span><br><span class="line">                type = FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        ), @<span class="title">ComponentScan</span>.<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">                <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">                classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">        )&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中需要注意的是@SpringBootConfiguration和@EnableAutoConfiguration。</p>
<p><strong>@SpringBootConfiguration</strong>这个注解表示这个类是SpringBoot的配置类，追踪进去再看这个注解，发现它只有一个注解，那就是@Configuration，这个注解是Spring中的注解，该注解用于表示此类是一个配置类，实锤SpringBoot是Spring的封装版本。</p>
<p><strong>@EnableAutoConfiguration</strong>这个注解是SpringBoot特有的注解，也是SpringBoot和Spring的最大区别之一，从名字就可以看出，这个注解实现了自动配置的功能。</p>
<p>以上知识的详细解释，我在解析SpringBoot底层原理的时候再叭叭，等我们上手使用SpringBoot后，并且对SpringBoot有一定认识的时候再学习底层原理就能事半功倍，刚写完Hello World就搞底层原理，你是个什么神仙？</p>
<h2 id="有没有更简单的HelloWorld"><a href="#有没有更简单的HelloWorld" class="headerlink" title="有没有更简单的HelloWorld?"></a>有没有更简单的HelloWorld?</h2><p>正所谓懒癌改变世界，有的人还觉得上面添加Maven配置太麻烦了，有没有更简单、更迅速构建SpringBoot的方法呢？还真有，除了手撸创建SpringBoot项目外，还有三种方法创建SpringBoot项目。</p>
<ol>
<li>官网下载</li>
<li>STS（Spring推荐的IDE，其实就是Eclipse魔改版）在线构建</li>
<li>Idea在线构建</li>
</ol>
<p>这里仅展示第三种方式，因为我很懒，展示三种实在太难为我了。</p>
<p>首先打开我们的Idea，创建一个新项目。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627185206771.png" alt="image-20200627185206771"></p>
<p>然后关键的一步来了</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627185419061.png" alt="image-20200627185419061"></p>
<p>弹出来一个奇奇怪怪的设置界面</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190820425.png" alt="image-20200627190820425"></p>
<p>小声bb：Group填自己的。我已经把上一个项目删掉了，所以我还是上一个项目的名字，你最好换一下。</p>
<p>点击下一步后出现一个乱七八糟的界面，这个界面是选择场景启动器（场景启动器后面再说），先跟着我做</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190403890.png" alt="image-20200627190403890"></p>
<p>点击下一步之后到了Idea项目设置的界面，点击完成</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200627190441384.png" alt="image-20200627190441384"></p>
<p>进去之后你会非常惊喜的发现，所有东西都已经配置完成了，只需要创建一个HelloWorldController就可以了，具体的操作我就不再演示了。</p>
<p>上述出现一个新名词叫场景启动器，什么是场景启动器呢？就是SpringBoot将某一场景中所需要用到的依赖打包，例如，我们需要web开发就会在依赖中添加一个叫做spring-boot-starter-web的场景启动器，如果需要测试呢？那么就添加对应的spring-boot-starter-test场景启动器。诸如此类的场景启动器还有很多，不仅有SpringBoot官方的启动器，很多第三方的应用或框架也提供了场景启动器，例如常用的mybatis框架也有SpringBoot的启动器。这些启动器除了打包一堆依赖之外，还添加了一些让人惊喜的小工具，比如web场景启动器内嵌了一个Servlet容器，可以让我们不用再部署到Tomcat。</p>
<h2 id="SpringBoot的配置"><a href="#SpringBoot的配置" class="headerlink" title="SpringBoot的配置"></a>SpringBoot的配置</h2><p>上面讲了SpringBoot开发的到底有多方便，那么问题来了，我该怎么配置SpringBoot呢？比如我要配置Tomcat的监听端口号，总不能让我修改SpringBoot的源码把8080改成80吧？难道还是老样子用xml配置文件？SpringBoot可是说了零xml配置文件。于是SpringBoot默认使用properties文件配置SpringBoot，并且引入了另一种配置文件yml（迷惑行为）。使用这两种全局配置文件来取代SpringBoot中默认的配置。</p>
<p>SpringBoot更加专注于约定，而非配置。什么意思呢？我们先来看一个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里使用的是以spring*.xml的通配符方式加载配置的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是SSM框架中web.xml的一个例子。这里指定了Spring的配置文件的路径以及文件名，web容器通过这个路径和文件名去加载Spring的配置文件，这就是通过配置web.xml来配置组件。而SpringBoot中并没有web.xml文件，那么SpringBoot怎么知道我们的配置文件在哪呢？SpringBoot<strong>约定</strong>了几个目录：</p>
<ol>
<li>recourse目录</li>
<li>recourse目录下的/config目录</li>
<li>项目的根目录</li>
<li>项目根目录下的/config目录</li>
</ol>
<p>并且将文件名也约定好了，全局配置文件名一定要叫application.properties或者application,yml（当然也可以取其他名字，这个后面会讲）。</p>
<p>约定好之后，SpringBoot就可以根据这些目录和文件名进行扫描，排列组合也不过八种情况嘛，这些配置文件也是有优先级的，并且重复配置后，优先级低的配置文件不会覆盖优先级高的配置文件。优先级排序规则如下：</p>
<ol>
<li>项目根目录＞recourse目录</li>
<li>/config目录＞不带/config目录</li>
<li>application.properties&gt;application.yml</li>
</ol>
<p>耐人寻味的是，我们平常最常用的就是recourse目录下的application.yml，嗯……最低优先级。</p>
<p>properties文件相信大家在开发中都使用过，最常用的就是log4j和数据库信息的配置，这里我们就不再赘述了，需要讲解的是yml文件，这个文件看起来和xml有点关系，盲猜下一代配置文件叫zml文件，下面就来讲解yml文件究竟怎么用。</p>
<h3 id="YML文件"><a href="#YML文件" class="headerlink" title="YML文件"></a>YML文件</h3><p>YML相较于XML更加轻盈，来看一个例子</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="meta">server.host</span>=<span class="string">localhost</span></span><br></pre></td></tr></table></figure>

<p>三种方式对比后，高下立判。YML使用缩进来表示层级，相较于XML使用标签来表示层级显然更加轻盈，你看这区别像不像Java用大括号界定代码块和Python用缩进界定代码块？哦对，还有lisp圆括号，代码最后一页全都是))))))))))))))))))))))))))))))。相比较properties文件来说分层也更为明显，可读性显然比properties更加优秀，语法上反而和properties一样轻量。</p>
<p>yml的基本语法规则如下：</p>
<ol>
<li>使用缩进表示层级关系</li>
<li>不允许使用tab缩进，只能使用空格（IDE都有自动转换，放心tab）</li>
<li>缩进空格不重要，只要同层级的保持空格数量相同即可，也就是说一个空格就可以表示层级</li>
<li>大小写敏感</li>
<li>基本语法为：key:(空格)value，空格千万必要忘记！</li>
</ol>
<p>yml的value有以下写法：</p>
<ol>
<li><p>字面量：包括字符串、数字、布尔值。字符串默认不需要双引号。</p>
</li>
<li><p>键值对：可以用来表示Map和对象。例如表示server有两个有两种写法：</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">context:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span> <span class="string">&#123;port:</span> <span class="number">8080</span><span class="string">,context:</span> <span class="string">hello&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组：嗯……就数组呗。</p>
<p> 直接表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> </span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br></pre></td></tr></table></figure>

<p> 行内表示：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">animals:</span> <span class="string">[pig,cat,dog]</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>这三种数据结构可以任意组合，无限套娃。下面来演示怎么将配置文件读取到Java中。</p>
<h3 id="读取配置文件到Java"><a href="#读取配置文件到Java" class="headerlink" title="读取配置文件到Java"></a>读取配置文件到Java</h3><p>先创建一个类——Cat。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Cat&gt; friends;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略一堆getter和setter方法。</span></span><br><span class="line">    <span class="comment">//可以按alt+insert自行插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再创建一个类——Host。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//省略getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编辑application.yml配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cat:</span><br><span class="line">  name: 蓝莓</span><br><span class="line">  age: <span class="number">21</span></span><br><span class="line">  host:</span><br><span class="line">    name: 周某某</span><br><span class="line">  toys:</span><br><span class="line">    - 毛球</span><br><span class="line">    - 逗猫棒</span><br><span class="line">    - 猫薄荷</span><br><span class="line">    - 周某某的头发</span><br><span class="line">  friends:</span><br><span class="line">    mary: <span class="string">"mary的主人"</span></span><br></pre></td></tr></table></figure>

<p>代码写好了，SpringBoot问你，Cat类是哪个配置文件负责配置的？你说就那个cat:开始的呗，SpringBoot又说了，别的包也有一个Cat类（假装有），我不知道注入哪一个Cat，要不你给我打个注解？好让我知道哪个Cat需要我管理，还有这个Cat是哪段配置文件配置的。</p>
<p>于是拿着SpringBoot给我们的两个注解，@ConfigurationProperties和@Component，放在了Cat的头上，Cat变成了这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以开始运行了！</p>
<p>还是用我们的HelloWorld类测试运行（也可以使用测试类进行测试。）</p>
<p>编辑HelloWorld类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么这样写可以看我的另一篇博客，白话Spring（一）</span></span><br><span class="line">    <span class="comment">//如果Bean有构造函数，那么可以省略@AutoWired : If a bean has one constructor, you can omit the @Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="读取非全局配置文件到Java"><a href="#读取非全局配置文件到Java" class="headerlink" title="读取非全局配置文件到Java"></a>读取非全局配置文件到Java</h3><p>上面讲到怎么把application.yml配置文件读取到Java中，那如果我有很多配置文件呢？难道都要写进application中嘛？那全局配置文件得多臃肿，修改起来也不方便，所有我们需要将部分配置信息分离出一个单独的文件。</p>
<p>SpringBoot中提供了一个@PropertySource注解，我们先看看这个注解都有什么东西</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(PropertySources<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">PropertySource</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">ignoreResourceNotFound</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">encoding</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends PropertySourceFactory&gt; factory() <span class="keyword">default</span> PropertySourceFactory<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个注解提供了四个值</p>
<ol>
<li>name：名称 默认为空</li>
<li>value：字符串数组，存放需要导入的配置文件路径。</li>
<li>ignoreResourceNotFound：配置文件没找到，要不要告诉你。默认false，也就是告诉你。</li>
<li>encoding：编码方式。</li>
</ol>
<p>通过上面的四个值我们可以看出这个注解可以加载多个配置文件，现在就来实战。</p>
<p>将application.yml重命名为cat.yml，修改Cat类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:cat.yml"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"cat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; toys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Cat&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", host="</span> + host.getName() +</span><br><span class="line">                <span class="string">", toys="</span> + toys +</span><br><span class="line">                <span class="string">", friends="</span> + friends +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>刷新界面，仍旧可以读取。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200628202503398.png" alt="image-20200628202503398"></p>
<h3 id="SpringBoot多环境下的配置"><a href="#SpringBoot多环境下的配置" class="headerlink" title="SpringBoot多环境下的配置"></a>SpringBoot多环境下的配置</h3><p>上面我说到SpringBoot和我们约定好了一起把全局配置写到名为application文件中，我也提到了可以使用别的名字。那么什么时候我们需要使用别的名字呢？也就是SpringBoot运行环境不同的时候，我们需要不同的配置文件来配置SpringBoot，比如开发环境通常端口号是8080、生产环境端口号看老大心情。我们总不能每次换一个环境就把全局配置文件进行修改吧？估计改个几次配置文件就面目全非，找不到头尾。SpringBoot也不是那么死板的只读取application文件，多一个字少一个字都不行。</p>
<p>SpringBoot允许我们添加多个命名为application-{环境名}.yml的application配置文件。</p>
<p>例如：开发环境可以命名为：application-dev.yml或者application-dev.properties；生产环境可以命名为：application-proc.yml；测试环境可以命名为：application-test.yml</p>
<p>我们先创建上面三个不同环境下的application配置文件，分别给这三个配置文件写上：</p>
<p>application-dev.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">6666</span></span><br></pre></td></tr></table></figure>

<p>application-proc.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7777</span></span><br></pre></td></tr></table></figure>

<p>application-test.yml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>对了，还有不带后缀的配置文件application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>现在直接运行，SpringBoot会使用不带后缀的配置文件来配置SpringBoot。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629115552251.png" alt="image-20200629115552251"></p>
<p>可以看到端口号是application.yml中所配置的端口号。</p>
<p>怎么告诉SpringBoot本次运行需要使用哪个配置文件呢？有以下几种方式：</p>
<ol>
<li><p>修改默认配置文件：</p>
<p> 在application.yml文件中添加</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure>

<p> 这里指定了使用后缀名为dev的配置文件，运行后结果：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629120126819.png" alt="image-20200629120126819"></p>
</li>
</ol>
<pre><code>也就是SpringBoot会先去application.yml中看spring.profiles.active是否配置了另一个全局配置文件，如果配置了，就只使用相应后缀的配置文件。</code></pre><ol start="2">
<li><p>命令行模式：</p>
<p> 运行时直接加在运行jar包命令的后面 –spring.profiles.active=proc，这种方式牵扯到SpringBoot的打包和运行，不过我们在IDEA中也可以使用增加选项的方式来测试。</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629121313373.png" alt="image-20200629121313373"></p>
<p> 在配置环境中添加–spring.profiles.active=proc（意思为生产环境）</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629121913696.png" alt="image-20200629121913696"></p>
<p> 运行之后结果：</p>
<p> <img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122015786.png" alt="image-20200629122015786"></p>
<p> 等等？我们在application.yml中配置了使用dev后缀的配置文件，命令行配置了proc后缀的配置文件，然而现在SpringBoot使用了proc的配置，OK，命令行方式会覆盖application中的配置。</p>
</li>
<li><p>虚拟机参数：</p>
</li>
</ol>
<pre><code>![image-20200629121313373](https://gitee.com/vanbyz/images/raw/master/img/image-20200629121313373.png)

在vm选项中添加-Dspring.profiles.active=test</code></pre><p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122816187.png" alt="image-20200629122816187"></p>
<p>运行之后：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629122015786.png" alt="image-20200629122015786"></p>
<p>嗯？怎么还是proc的端口？命令行选项没有删除，也就是命令行优先级高于虚拟机配置，把命令行选项删除，再次运行。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629123135251.png" alt="image-20200629123135251"></p>
<p>这个就是test的端口号了，但是别忘了application.yml中的配置文件从来都没有删除过spring.profiles.active=dev这个配置项。</p>
<p>所以这三种配置的优先级是：命令行选项 &gt; 虚拟机选项 &gt; application中配置</p>
<h2 id="SpringBoot注册组件"><a href="#SpringBoot注册组件" class="headerlink" title="SpringBoot注册组件"></a>SpringBoot注册组件</h2><p>SpringBoot虽然可以使用@ImportRecourse注解导入Spring的xml配置文件（也就是创建Bean），但是SpringBoot不推荐这种办法，而是使用配置类来添加组件。</p>
<p>首先需要告诉SpringBoot这是一个配置类也就是前面讲过的@Configuration注解，SpringBoot会在扫描的时候将这个配置类添加到自己的小本本里。SpringBoot得知这是个配置类之后，你需要告诉它这个配置类是做什么的，Spring提供了一个注解@Bean，这个注解标注在一个方法上，它会将标注方法的返回值注册进容器。</p>
<p>来看一个例子：</p>
<p>根包目录下创建一个config包，并创建一个ConfigDemo类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//标注为配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Host <span class="title">host</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值类型是要注册的组件类，方法名是该组件在SpringBoot中的id</span></span><br><span class="line">        System.out.println(<span class="string">"创建Host成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Host(<span class="string">"小王"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再魔改一下我们的HelloWorld类（controller包中的，曾经的HelloWorld成为了我们的测试类……）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 周某某</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入组件</span></span><br><span class="line">    <span class="keyword">final</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"helloWorld"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后结果如下：</p>
<p>控制台：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629101604813.png" alt="image-20200629101604813"></p>
<p>浏览器：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629101623161.png" alt="image-20200629101623161"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>终于写完了……不算图一共五千字（废话有三千字），不知道有没有人能耐心看完……</p>
<p>先来总结下知识点：</p>
<ol>
<li>SpringBoot是什么？</li>
<li>HelloWorld怎么写？</li>
<li>如何通过Spring向导创建SpringBoot项目？</li>
<li>YML的基本语法以及怎么解析YML到Java？</li>
<li>全局配置文件的优先级</li>
<li>解析非全局配置文件到Java</li>
<li>SpringBoot读取不同环境下的全局配置文件的三种方式及优先级</li>
<li>通过配置类的方式注册组件到SpringBoot</li>
</ol>
<p>如果你看着这八条能够想起来步骤，那么这篇博客已经完成了它的使命，有任何不解请联系我，有问必答。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot学习笔记（二）：自动配置原理</title>
    <url>/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>INTRO:</strong>  上一篇博客讲解了SpringBoot的入门知识，了解到SpringBoot的精髓就是自动配置，自动配置的简便让SpringBoot在JavaEE领域大杀四方，学习SpringBoot自动配置的原理让我们知其所以然，博主写这篇博客就是为了让大家了解SpringBoot自动配置的原理。</p>
<a id="more"></a>

<h2 id="上文回顾"><a href="#上文回顾" class="headerlink" title="上文回顾"></a>上文回顾</h2><ol>
<li><p>SpringBoot是一个用于快速构建Spring应用的框架</p>
</li>
<li><p>创建HelloWorld步骤如下：</p>
<p> 新建maven项目；在pom.xml文件添加spring-boot-starter-parent父项目、添加spring-boot-starter核心场景启动器、添加spring-boot-starter-web场景启动器；创建controller.HelloWorld类；使用@RestController注解标注HelloWorld；使用@RequestMapping标注helloWorld()方法；在浏览器访问localhost:8080/helloWorld。</p>
</li>
<li><p>略</p>
</li>
<li><p>YML语法简单来说就是区分大小写的键值对key:(空格)value，数组使用（空格）-（空格）表示；解析YML到Java可以使用@ConfigurationProperties(“前缀”)，即可自动注入。</p>
</li>
<li><p>全局配置文件的优先级规则如下：/config比不带/config的高；项目根目录比classpath目录高；properties比yml高。</p>
</li>
<li><p>非全局文件导入需要我们使用@PropertySource(“配置文件路径+文件名”)来引入配置文件</p>
</li>
<li><p>给不同环境所使用的配置文件加-后缀，可以使用的方式及其配优先级为命令行参数-&gt;虚拟机参数-&gt;配置文件</p>
</li>
<li><p>SpringBoot使用配置类取代了applicationContext.xml文件，使用@Configuration注解和@Bean注解来完成组件的注册。</p>
</li>
</ol>
<p>上一篇博客简单的对SpringBoot进行了入门讲解，从上篇博客中，我们了解到SpringBoot在开发过程中有多方便。但是开发过程中的写业务逻辑又和Spring非常相似，这就保证了我们学习SpringBoot的成本大大降低。那么SpringBoot靠什么保证了这些优点呢？SpringBoot的自动配置是怎么实现呢？本文会通过查看源代码的方式来讲解SpringBoot的工作原理，在讲解的过程中，博主还会说一下自己是怎么阅读源代码的（仅供参考……欢迎大家介绍自己方法）。</p>
<h2 id="博主是怎么阅读源码的"><a href="#博主是怎么阅读源码的" class="headerlink" title="博主是怎么阅读源码的"></a>博主是怎么阅读源码的</h2><p>首先简单讲一下我是怎么阅读源码的，我阅读源码分为几个步骤：</p>
<ol>
<li>先找线头、也就是从哪里开始看。</li>
<li>分块查看、查看核心方法的作用。按照调用方-&gt;参数-&gt;返回值的顺序查看，首要任务是弄明白这个核心方法做了什么事情。这一步有一个不算技巧的技巧，值得我们研究的源码都是优秀的源码，那么命名必定是规范明确的，我们可以通过方法名去推断这个方法的实际作用。对于核心方法调用的非核心方法，我们只需要通过方法名判断这个被调用的方法做了什么就可以了，不需要点进去查看。</li>
<li>机制总结、查看过核心代码的作用之后，我们需要看这个核心代码的机制是什么，也就是怎么实现这个功能的？实现这个功能分了几步？每步的顺序是什么？用了哪些设计模式？</li>
<li>理清原由、这一步就比较深入了，这一步需要我们认真思考代码作者在写这段代码的时候是怎么想的，为什么作者要这样写？这样设计有什么好处？还能否继续改进？</li>
</ol>
<p>在本文中，我们只需要看到第二步，更细致的解读我大概会在以后单独做一个系列，现在只需要了解SpringBoot的基本原理就行了。</p>
<h2 id="SpringBoot自动配置源码解读"><a href="#SpringBoot自动配置源码解读" class="headerlink" title="SpringBoot自动配置源码解读"></a>SpringBoot自动配置源码解读</h2><h3 id="找线头"><a href="#找线头" class="headerlink" title="找线头"></a>找线头</h3><p>按照上面分享的阅读源码的方式，我们要先找到线头，线头当然是我们的main方法，那这个main方法有什么特殊的呢？没错，就是头上顶着的那个@SpringBootApplication注解，点进去看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></table></figure>

<p>嗯……上一篇博客已经讲过这个了，这里再回顾下，@SpringBootConfiguration的底层是Spring中的@Configuration，告诉SpringBoot这是一个配置类。（你看，这不学Spring的话，SpringBoot源码就难搞）</p>
<p>看下一个注解，光看名字就很重点@EnableAutoConfiguration，翻译下叫做开启自动配置。嘿！这不是今天这个博客的主要研究对象吗？线头找到了，下一步！</p>
<h3 id="粗看代码"><a href="#粗看代码" class="headerlink" title="粗看代码"></a>粗看代码</h3><p>点进@EnableAutoConfiguration注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<p>又是两个注解的组合，我们一个一个的看，先看@AutoConfigurationPackage（自动配置包）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Import这个注解要说说，这个注解也是Spring中的注解，意思就是导入配置类。</p>
<p>查看这个Registrar类，发现它是一个静态内部类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">       Registrar() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">           AutoConfigurationPackages.register(registry, (String[])(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImports(metadata));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>定义了两个方法registerBeanDefinitions（注册Bean）、determineImports（确认导入）。</p>
<p>看registerBeanDefinitions方法调用了一个注册方法，通过方法名我们可以推断是注册Bean到容器中。后面还创建了一个AutoConfigurationPackages对象，并且将这个对象中的存放的包名作为值传了出去。这个包名是谁的包名呢？看PackageImport(metadata)，这里传入了一个注解元数据信息，我们在这一行打一个断点，然后debug的方式运行。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629175634050.png" alt="image-20200629175634050"></p>
<p>没错，这个元数据表明这个注解在SpringBootDemo类上，通过这个元数据信息，PackageImports计算出basePackages，然后通过for循环将这个包下所有的子包都添加进packageNames中。ok，绕了一大圈原来SpringBoot通过@SpringBootApplication -&gt; @EnableAutoConfiguration -&gt; @AutoConfigurationPackage -&gt; @Import注解的元数据知道主配置类（被@SpringBootApplication标注的类）所在的包，然后将主配置类所在包的所有子包都放到packageNames中存储起来。也就是SpringBoot注册组件时，需要扫描的包。类比Spring的配置文件，它可以取代以下配置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"org.exmples.xxx"</span>&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<p>虽然看着麻烦，其实SpringBoot都私下帮你做好了。</p>
<p>再来看@EnableAutoConfiguration的另一个注解：@Import({AutoConfigurationImportSelector.class})</p>
<p>Import注解之前说过了，它用来导入配置类，那么我们看看AutoConfigurationImportSelector（自动配置导入选择器）类。</p>
<p>这个类里面的东西比较多，我们主要关注的内容是selectImports()方法，其他所有的都是为这个方法做辅助。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">           <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry</span><br><span class="line">               =<span class="keyword">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">           <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>selectImports主要调用了getAutoConfigurationEntry()方法根据注解元数据获取AutoConfigurationEntry对象，然后将对象中存储的配置返回。</p>
<p>首先我们来查看 AutoConfigurationEntry 的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationEntry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; configurations;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; exclusions;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AutoConfigurationEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configurations = Collections.emptyList();</span><br><span class="line">        <span class="keyword">this</span>.exclusions = Collections.emptySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AutoConfigurationEntry(Collection&lt;String&gt; configurations, Collection&lt;String&gt; exclusions) &#123;</span><br><span class="line">        <span class="keyword">this</span>.configurations = <span class="keyword">new</span> ArrayList(configurations);</span><br><span class="line">        <span class="keyword">this</span>.exclusions = <span class="keyword">new</span> HashSet(exclusions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getConfigurations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getExclusions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.exclusions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码我们可以看出AutoConfigurationEntry中按照List的结构存放configuration。这些配置如何存放进AutoConfigurationEntry中的呢？通过代码可以看出实例对象都是找getAutoConfigurationEntry()方法拿的，我们去问它好咯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry </span><br><span class="line">    getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AnnotationAttributes attributes = <span class="keyword">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">            <span class="comment">//下面这一行很重要</span></span><br><span class="line">            List&lt;String&gt; configurations = <span class="keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = <span class="keyword">this</span>.removeDuplicates(configurations);</span><br><span class="line">            Set&lt;String&gt; exclusions = <span class="keyword">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            <span class="keyword">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            <span class="comment">//下面这一行也很重要</span></span><br><span class="line">            configurations = <span class="keyword">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">            <span class="keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码逻辑还是比较简单清晰的，首先创建两个集合框架，通过给getCandidateConfigurations（获取候选配置）方法传入注解元数据信息和属性信息来获取configurations，随后调用removeDuplicates()方法进行去重处理，这时出现了一个exclusions，这里存放不需要自动装配的组件，configurations将这些组件移除（此时CandidateConfigurations才真正变为configurations），又经过getConfigurationClassFilter过滤器的过滤之后才将其返回给selectImports方法。很明显在这一段代码中，需要我们注意的两个方法是getCandidateConfigurations()和filter()。</p>
<p>先来看getCandidateConfigurations()，它负责收集所有的候选组件，然后这些组件经过去重、去排除、经过滤器后才被注册。</p>
<p>点进去后发现关键代码就一句</p>
<p>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</p>
<p>果然还是绕到Spring中来了，来都来了，看看呗。loadFactoryNames调用了loadSpringFactories方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">            LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                URL url = (URL)urls.nextElement();</span><br><span class="line">                UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                    String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                    <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                        String factoryImplementationName = var9[var11];</span><br><span class="line">                        result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cache.put(classLoader, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到通过类加载器读取了下的META-INF/spring.factories，我们找找这个在哪。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629224844085.png" alt="image-20200629224844085"></p>
<p>看第二个spring-boot-autoconfigure点开，为什么直奔第二个，男人的直觉，哼哼！</p>
<p>再点开META-INF/spring.factories文件，可以看到一堆的全限定类名，SpringBoot会将全限定类名全部注册到容器中。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200629225232015.png" alt="image-20200629225232015"></p>
<p>出现在这里的全限定类名都将加入到SpringBoot容器中，只有加入到容器中的类才能被Springboot进行配置。</p>
<p>没错，云里雾里讲了那么久，自动配置的原理才刚刚开始。讲的有点乱，所以到这里先捋一捋。</p>
<p>SpringBoot会自动配置一些组件（比如我们的server组件的server.port），SpringBoot有哪些组件会自动配置，SpringBoot又是怎么配置这些组件呢？首先这些组件需要加载进SpringBoot中，这样才能被SpringBoot管理。使用@SpringBootApplication中的@EnableAutoConfigration会读取org.springframe.boot:spring-boot-autoconfigure依赖的META-INF/spring.factories文件的一系列全限定类名，SpringBoot通过这些全限定类名加载进容器中，那么SpringBoot就能通过反射+全限定类名创建自动配置组件的实例对象。</p>
<p>讲完SpringBoot怎么自动将自动配置组件注册进容器中后，再学习这些自动配置组件是怎么自动配置的。</p>
<p>我们选择一个常用的数据源配置项所属的自动配置类来分析</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br></pre></td></tr></table></figure>
</blockquote>
<p>按住ctrl点击这个类，查看这个类的源代码，发现这个类有一大堆注解，我们来一个一个分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">EmbeddedDatabaseType</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= &#123;<span class="string">"io.r2dbc.spi.ConnectionFactory"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;DataSourceProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123;DataSourcePoolMetadataProvidersConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">DataSourceInitializationConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先是@Configuration注解，这个我们都不陌生，表示被标注的类是一个配置类。</p>
<p>其次是@ConditionalOnClass注解，这个注解是Spring中的注解，意思就是如果有DataSource和EmbeddedDatabaseType才会创建这个Bean。你可以左键单击这两个类，发现找不到EmbeddedDatabaseType，因为你没有添加DataSource的依赖，也就是说SpringBoot不会帮你自动配置DataSource。</p>
<p>然后是@ConditionalOnMissingBean注解，看名字是只有io.r2dbc.spi.ConnectionFactory这个Bean不存在的时候才会创建Bean，这是DataSource，至于这个Bean是什么，需要我们学习相关的启动器了。</p>
<p>下一个是@EnableConfigurationProperties注解，这个注解看起来很熟悉，像是我们之前用过的@ConfigurationProperties注解，不知道大家还有没有印象，@ConfigurationProperties注解用于配置类读取配置文件信息。再看@EnableConfigurationProperties注解中导入的类文件DataSourceProperties.class，追踪进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.datasource"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title">BeanClassLoaderAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> generateUniqueName = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends DataSource&gt; type;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String jndiName;</span><br><span class="line">    <span class="keyword">private</span> DataSourceInitializationMode initializationMode;</span><br><span class="line">    <span class="keyword">private</span> String platform;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; schema;</span><br><span class="line">    <span class="keyword">private</span> String schemaUsername;</span><br><span class="line">    <span class="keyword">private</span> String schemaPassword;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; data;</span><br><span class="line">    <span class="keyword">private</span> String dataUsername;</span><br><span class="line">    <span class="keyword">private</span> String dataPassword;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> continueOnError;</span><br><span class="line">    <span class="keyword">private</span> String separator;</span><br><span class="line">    <span class="keyword">private</span> Charset sqlScriptEncoding;</span><br><span class="line">    <span class="keyword">private</span> EmbeddedDatabaseConnection embeddedDatabaseConnection;</span><br><span class="line">    <span class="keyword">private</span> DataSourceProperties.Xa xa;</span><br><span class="line">    <span class="keyword">private</span> String uniqueName;</span><br><span class="line">    <span class="comment">//省略一堆方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这些属性和头上的@ConfigurationProperties注解，恍然大悟，这是来到DataSource配置类了，这个前缀表示如果我们像配置数据源信息就要使用层级为spring.datasource开始的配置（对这块有疑问的可以回头看看上一篇博客，或者根据博客底部的联系方式联系我）。这么看来@EnableConfigurationProperties这个注解就是来给皇军带路的。</p>
<p>但是这个DataSourceProperties配置类怎么用呢？。接下来就是见证奇迹的时刻，我们来看DataSourceAutoConfiguration类中最后一个注解@Import()，这个注解之前说过了，就是给这个类导入组件的，这里导入了两个类——数据源池元数据提供程序配置.class和数据源初始化配置.class，我们先看</p>
<p>DataSourcePoolMetadataProvidersConfiguration.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourcePoolMetadataProvidersConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataSourcePoolMetadataProvidersConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;BasicDataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">CommonsDbcp2PoolDataSourceMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        CommonsDbcp2PoolDataSourceMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意这个注解</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">commonsDbcp2PoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                BasicDataSource dbcpDataSource = (BasicDataSource)DataSourceUnwrapper.unwrap(dataSource, BasicDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> dbcpDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> CommonsDbcp2DataSourcePoolMetadata(dbcpDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;HikariDataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">HikariPoolDataSourceMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        HikariPoolDataSourceMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意注意</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">hikariPoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                HikariDataSource hikariDataSource = (HikariDataSource)DataSourceUnwrapper.unwrap(dataSource, HikariDataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> hikariDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> HikariDataSourcePoolMetadata(hikariDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span>(</span><br><span class="line">        proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="meta">@ConditionalOnClass</span>(&#123;DataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">static</span> <span class="title">class</span> <span class="title">TomcatDataSourcePoolMetadataProviderConfiguration</span> </span>&#123;</span><br><span class="line">        TomcatDataSourcePoolMetadataProviderConfiguration() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span><span class="comment">//注意注意</span></span><br><span class="line">        <span class="function">DataSourcePoolMetadataProvider <span class="title">tomcatPoolDataSourceMetadataProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (dataSource) -&gt; &#123;</span><br><span class="line">                DataSource tomcatDataSource = (DataSource)DataSourceUnwrapper.unwrap(dataSource, DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">return</span> tomcatDataSource != <span class="keyword">null</span> ? <span class="keyword">new</span> TomcatDataSourcePoolMetadata(tomcatDataSource) : <span class="keyword">null</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得@Bean这个注解吗？这个注解上一篇博客中讲过，用于给Springboot中注册组件。这三个注解根据存在不同的类可以注册不同的datasource到SpringBoot容器中，然后datasource这个依赖就可以注入DAO层框架（例如Mybatis）了。</p>
<p>根据这个注解，我们就知道，SpringBoot自动配置支持的三个datasources pool是：</p>
<ol>
<li>tomcatPool</li>
<li>hikariPool(号称最快的数据源池，我没试过，有空玩玩)</li>
<li>dbcp2</li>
</ol>
<p>上面的知识并不是我们的目的，只是为了展示我们阅读源码的目的，你看我们通过阅读源码知道了为什么自动配置只支持这三个数据源池，而不是简单通过官方文档中的知其然而不知其所以然。</p>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>限于篇幅问题（我太懒……），这篇博客不再详细进行源码解读的第三步第四步了。</p>
<p>接上半场的总结，SpringBoot通过一系列的注解找到spring-boot-autoconfigure依赖包下的META-DATA/spring.factories文件，这个文件中含有很多自动配置类的全限定类名，SpringBoot通过这些全限定类名，将这些自动配置类记录下来（还没创建Bean）。通过这些类上的@Conditional系列注解来判断是否创建这个自动配置类的Bean，经过重重筛选，符合当前开发环境的自动配置类会通过@EnableConfigurationProperties注解设置配置类，而这个配置类的配置信息通过设置前缀名来读取全局配置文件中对应的配置信息。自动配置类又会通过@Bean注解将配置类中的配置信息利用起来，返回一个我们可以使用的Bean（例如配置好的datasource）。其他组件可以使用依赖注入的方式调用这个配置好的Bean。</p>
<p>简单来说，SpringBoot的自动配置分为两部分:</p>
<ol>
<li>注册自动配置类，这些类命名为xxxAutoConfiguration。这一部分又可以细分为下面步骤：<ul>
<li>@SpringApplication -&gt; @EnableAutoConfiguration </li>
<li>设置基础包，包为@SpingApplication标注类所在的包</li>
<li>利用iSpringFactoriesLoader读取META-DATA/spring.factories文件，将里面的url记录进SpringBoot。</li>
</ul>
</li>
<li>自动配置<ul>
<li>根据@Conditional注解筛选需要注册为Bean的自动配置类</li>
<li>自动配置类通过@EnableConfigurationProperties注解让xxxProperties配置类读取配置文件</li>
<li>自动配置类利用配置类中的信息初始化组件，并通过@Bean注解将组件的注册为Bean。</li>
</ul>
</li>
</ol>
<p>面试中这样说……大概可以吧？</p>
<p>这一章理论知识比较多，请大家把这条线捋一下，我只是简单的把自动配置这条路线走了一遍，有精力的同学可以再细致研究这些功能的实现机制。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记（一）：Redis基础入门</title>
    <url>/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARedis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> 在实际开发过程中，我们会经常用到Redis，作为一个高速缓存数据库，我们该从哪里开始学习呢？本文参考Redis文档作为大纲编写，从这篇博客开始开辟Redis这个高速公路。</p>
<a id="more"></a>

<h2 id="Redis是个啥？"><a href="#Redis是个啥？" class="headerlink" title="Redis是个啥？"></a>Redis是个啥？</h2><p>Redis本质上是一个以key-value存储的数据库。那么key-value数据库可太多了，我们为什么都用redis呢？</p>
<p>因为Redis是一个内存数据库，并且支持数据持久化，这里解释一下数据持久化。</p>
<p><strong>数据持久化：</strong>其实这个词学过数据库的都会知道什么意思，但是照顾下初学者（顺便凑凑字数）还是说一说。我们以前的程序都是在内存玩玩，包括我们第一个程序HelloWorld也好，各种排序算法也好，这些东西都是在内存中的。只要我们关闭程序或者计算机断电，所有的东西就都没了（参考老版本的Word文档）。那么我们的数据存在哪里才不会受到这种限制呢？那当然是硬盘啦！像Mysql、Oracle这种就是将数据存进硬盘中，那么问题来了，硬盘它读写速度慢啊！访问量一上去，读写速度直接成为系统瓶颈。于是有大佬想出一个办法，我把常用数据存在内存中不就行了吗？Redis就在这种背景下横空出世。</p>
<p><strong>Redis的优势</strong>： 刚才讲到Redis的出生背景，可能有些人开始疑惑了，这不是开倒车吗？刚说完数据持久化，你就把数据放到内存了。万一服务器断电，数据不就没了？大佬毕竟是大佬，只要大佬高可用做的好，灾难就追不上大佬。Redis支持主从模式的数据备份，主挂了，我还有从呢！Redis支持数据持久化，可以把数据存进硬盘中，等到重启的时候再拿出来用。（大胆猜测下，向Redis写入数据时，Redis需要做三件事：存数据到主节点内存；同步数据到从节点；同步数据到硬盘。我们在学习过程中再看到底是不是这样。）</p>
<h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>入门第一步当然是先安装主角啦！进入<a href="https://redis.io/" target="_blank" rel="noopener">Redis官网</a>寻找Download关键字，看到Download相关的点进去就完事了。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709100113889.png" alt="image-20200709100113889"></p>
<p>点击一下，直接就下载了。默认时linux版本的gz文件，如果你想下载windows版本的可以在这里<a href="https://github.com/tporadowski/redis/releases" target="_blank" rel="noopener">gayhub</a>下载安装。我这里有一台Linux服务器，我就使用linux版本了。希望大家有条件的可以创建虚拟机来操作Linux。</p>
<p>偷偷告诉大家一个小技巧，win10自带的Powershell可以直接使用ssh/scp来链接服务器或者上传文件。</p>
<p>我这里使用的ssh工具是Termius，好用倒是没多好用，就是界面美观。scp就用Powershell了。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709102039501.png" alt="image-20200709102039501"></p>
<p>不得不说微软现在越来越开放了，像VS Code、Powershell等都支持跨平台了，我的青春结束了。</p>
<p>来到服务器，在/root目录运行解压redis安装包</p>
<blockquote>
<p>tar -zxvf  redis-6.0.5.tar.gz</p>
</blockquote>
<p>进入目录并且编译</p>
<blockquote>
<p>cd redis-6.0.5/ &amp;&amp; make</p>
</blockquote>
<p>如果编译期间报错，那么就是你的gcc版本出现问题，两种解决方案：升级gcc；使用更低的Redis版本；</p>
<p>*注意！生产环境中不可擅自升级gcc，凡事先问运维可不可以升级！</p>
<p>我这里选择升级gcc，按顺序运行这些命令，然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y cpp</span><br><span class="line">yum install -y binutils</span><br><span class="line">yum install -y glibc</span><br><span class="line">yum install -y glibc-kernheaders</span><br><span class="line">yum install -y glibc-common</span><br><span class="line">yum install -y glibc-devel</span><br><span class="line">yum install -y gcc</span><br><span class="line">yum install -y make</span><br><span class="line"></span><br><span class="line">yum -y install centos-release-scl</span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"></span><br><span class="line">echo "source /opt/rh/devtoolset-9/enable" &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure>

<p>运行命令</p>
<blockquote>
<p>src/redis-server</p>
</blockquote>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709111549533.png" alt="image-20200709111549533"></p>
<p>出现这个就说明Redis的server端启动起来了，可以通过redis内置的一个客户端与服务端进行交互。</p>
<p>因为这个被占用了，另开一个ssh链接。</p>
<p>运行命令</p>
<blockquote>
<p>src/redis-cli</p>
</blockquote>
<p>这个时候进入了redis命令行模式，我们输入set的时候，redis会自动给我们提示</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709112032802.png" alt="image-20200709112032802"></p>
<p>小声bb：Mysql赶紧跟人家学学！</p>
<p>然后，在命令行输入</p>
<blockquote>
<p>set hello world</p>
</blockquote>
<p>输出OK，表示我们已经完成了key-value的添加</p>
<p>输入</p>
<blockquote>
<p>get hello</p>
</blockquote>
<p>输出 “world”</p>
<p>至此一个简单的测试用例就完成了。如果你觉得安装redis还需要使用虚拟机有点麻烦，并且你不想redis占用资源，那么你可以通过<a href="https://try.redis.io/" target="_blank" rel="noopener">在线Redis</a>，来学习Redis。</p>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis的配置文件是位于安装目录下的<strong>redis.conf</strong>文件，可以通过Config来查看或者配置Redis。</p>
<p>格式为：</p>
<blockquote>
<p>CONFIG GET CONFIG_NAME</p>
</blockquote>
<p>例如我们可以输入 CONFIG GET * 来查看所有的配置</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200709125521604.png" alt="image-20200709125521604"></p>
<p>从这里们可以看出配置文件的结构是两行为一个配置，奇数行是配置名，这个奇数行下面的偶数行是该配置项的值。</p>
<p>也就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;配置名xxx&quot;</span><br><span class="line">2) &quot;xxx的值&quot;</span><br></pre></td></tr></table></figure>

<p>我们会在后面的知识讲解这些配置项的含义。</p>
<p>先使用CONFIG GET PORT查看redis日志的等级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET loglevel</span><br><span class="line">&quot;loglevel&quot;</span><br><span class="line">&quot;notice&quot;</span><br></pre></td></tr></table></figure>

<p>使用CONFIG SET CONFIG_NAME CONFIG_VALUE 的格式可以设置配置项的值，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG SET loglevel warning</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>再查看的时候结果就变了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET loglevel</span><br><span class="line">&quot;loglevel&quot;</span><br><span class="line">&quot;warning&quot;</span><br></pre></td></tr></table></figure>

<p>题外话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Warning: since Redis is pretty fast an outside user can try up to 150k passwords per second against a good box. This means that you should use a very strong password otherwise it will be very easy to break.</span><br><span class="line">因为redis速度太快，所以暴力破解密码也很快，如果你的redis地址暴露，数据安全岌岌可危。</span><br></pre></td></tr></table></figure>

<h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><p>Redis支持五种基本的数据结构：</p>
<p><strong>String：</strong>这是Redis中最基本的元素，它不仅仅可以存储我们日常中的字符串，它还能存储一些音乐、图片，甚至序列化之后的Java对象(你想到了什么？)，一个String最多可以存储<strong>512MB</strong>的内容。</p>
<blockquote>
<p>SET url “blooog.top”</p>
<p>OK</p>
<p>GET url</p>
<p>“blooog.top”</p>
</blockquote>
<p><strong>Hash：</strong> Redis中的Hash是一系列键值对的集合，类似于Java中的Map，Hash本质上是String类型的field和String类型的value的映射表，一个Hash映射表可以存储2<sup>32</sup> -1个键值对。</p>
<p>我们在Redis命令行敲上HMSET 出现一串提示：</p>
<blockquote>
<p>HMSET key field value [field value ……]</p>
</blockquote>
<p>根据这个结构我们输入一个Hash</p>
<blockquote>
<p>HMSET user:admin name zhouxx url blooog.top post redis</p>
</blockquote>
<p>然后使用命令</p>
<blockquote>
<p>HGETALL user:admin</p>
</blockquote>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;zhouxx&quot;</span><br><span class="line">3) &quot;url&quot;</span><br><span class="line">4) &quot;blooog.top&quot;</span><br><span class="line">5) &quot;post&quot;</span><br><span class="line">6) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p><strong>List：</strong> 类似于数组，里面可以存储 2<sup>32</sup> -1个String类型的元素，使用LPUSH命令可以进行存储，语法也比较简单，直接把要存进去的元素写在后面就行了。</p>
<p>例如：</p>
<blockquote>
<p>LPUSH exlist zhouxx blooog.top redis</p>
</blockquote>
<p>取出元素可以使用LRANGE命令</p>
<blockquote>
<p>LRANGE exlist 0 5</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;zhouxx&quot;</span><br></pre></td></tr></table></figure>

<p>注意，List中的顺序和们输入的顺序是相反的，为什么会这样呢？因为我们使用的是LPUSH，也就是按照输入的顺序从List左边插入。</p>
<p><strong>Set：</strong> 类似Java中的Set，你看着数据结构都是相通的，数据结构一定要学好，有机会开一个数据结构的博客。Set通过哈希表实现，所以它的添加、删除、查找的时间复杂的都是O(1)。</p>
<p>使用SADD KEY ELE添加元素，例如：</p>
<blockquote>
<p>SADD exset zhouxx</p>
<p>SADD exset blooog.top</p>
<p>SADD exset redis</p>
</blockquote>
<p>使用SMAMERS zhouxx命令查看集合中的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;zhouxx&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<p>同样的，Set中也可以存放2<sup>32</sup> -1个String类型的元素。</p>
<p>注意：Set中仅能存放不同的元素，第二次插入的相同元素会无效。</p>
<p><strong>Zset：</strong> 有序集合，Zset和Set相似，都不允许插入相同的元素，不同的是Zset中每个元素都有一个Score用来代表权值，Redis通过Score来进行排序。默认为正序，并且Score可以重复。</p>
<p>使用 ZADD KEY SCORE ELE添加元素，例如：</p>
<blockquote>
<p>ZADD exzset 12.12 zhouxx</p>
<p>ZADD exzset 11.11 blooog.top</p>
<p>ZADD exzset 6.18 redis</p>
</blockquote>
<p>使用ZRANGEBYSCORE KEY START END命令读取SCORE区间内的元素</p>
<blockquote>
<p>ZRANGEBYSCORE  exzset 6.18 12.12</p>
</blockquote>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;blooog.top&quot;</span><br><span class="line">3) &quot;zhouxx&quot;</span><br></pre></td></tr></table></figure>

<p>可以看出这个范围要求是双向闭区间。</p>
<h2 id="Redis和它的二百命令"><a href="#Redis和它的二百命令" class="headerlink" title="Redis和它的二百命令"></a>Redis和它的二百命令</h2><p>回顾全文，可以看出redis中的功能还是很强大的（并没有），数据结构还是很复杂的（并没有）。</p>
<p>命令还是很多的（这个是真的有！），据官网上说，Redis有二百多条命令。</p>
<p>Redis官方把根据命令负责的模块，将命令分为多个命令集，有了分类再掌握命令就方便了。官网也提供了快速查询的通道。</p>
<p>英文：<a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令查询</a></p>
<p>中文：<a href="https://redis.io/commands" target="_blank" rel="noopener">Redis命令查询</a></p>
<p>中文版的翻译不是很全，但是一些经常用的命令都做了翻译。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐的SpringMVC（一）：前后端分离下的SpringMVC</title>
    <url>/%E5%BF%AB%E4%B9%90%E7%9A%84SpringMVC%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8B%E7%9A%84SpringMVC/</url>
    <content><![CDATA[<p><strong>INTRO：</strong> SpringMVC主要负责MVC模式的实现。SpringMVC近几年来已经逐渐取代Struts2的地位，当然现在是SpringBoot大行其道，那么为什么还要学习SpringMVC呢？因为SpringBoot是Spring的封装，而SpringMVC又是Spring的组件，所以不学习SpringMVC就无法掌握SpringBoot的web部分。</p>
<a id="more"></a>

<h2 id="MVC是什么"><a href="#MVC是什么" class="headerlink" title="MVC是什么"></a>MVC是什么</h2><p>SpringMVC中最显眼的就是MVC，那么什么是MVC呢？MVC即Model、View、Controller。是不是听上去很懵逼？如果不使用MVC会怎样？胡子眉毛一把抓，直接在JSP中写上连接数据库的代码，有些同学疑惑了PHP不就是这样的嘛？Java是一个工程上的语言，虽然Java对设计模式等可能有些滥用的情况，但是这种前后端强耦合的情况Java是绝对不允许的。于是一些大佬就推广MVC模式，大佬是这样说的：任何应用程序设计都遵循MVC模式。View：视图，给用户看的；Model：模型，不同用户需要看到的不同资源；Controller：控制器，将Model和View结合。</p>
<p>MVC最常和什么技术一起使用呢？JSP（Java Server Page），当然JSP技术终将会被淘汰，但是这里使用JSP技术讲解MVC模式会更容易理解。JSP中使用JSTL标签库来标记什么地方需要插入动态数据（也就是你数据库查出来的东西），我们呈现给客户的是带有各种标签的原生界面嘛？并不是，而是经过替换标签、渲染完成的HTML，那么JSP是怎么变成HTML的呢？在SpringMVC中有一个视图解析器，它会将JSP文件拿出来，再将Model数据捏上去，合成一个HTML加到Response体中，再返回给浏览器。</p>
<p>有些新手可能会有误解，以为Model数据和JSP一起返回到浏览器，由浏览器进行渲染界面，这是错误的。还记得我们开发JSP过程中最讨厌的事情是什么嘛？JSP不能在浏览器中打开看样式！也就是说浏览器根本不知道你JSP是个啥，浏览器只认识HTML，所以JSP转换为HTML的过程是在服务器上进行的。</p>
<p>问题来了，MVC是怎么知道哪个JSP要和哪个Model数据捏在一起的呢？这就是Controller的作用啦！我们先写一个Controller实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    EmService emService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmController</span><span class="params">(EmService emService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emService = emService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"getAllem"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getAllem</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView;</span><br><span class="line">        List&lt;Em&gt; ems = emService.getAllEm;</span><br><span class="line">        <span class="comment">//注意这句</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">"/WEB-INF/views/all_em.jsp"</span>);</span><br><span class="line">        <span class="comment">//注意这句</span></span><br><span class="line">        modelAndView.addProject(<span class="string">"em"</span>,ems);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个Controller实例，从实例中看出来，我们通过Service层（严格意义上来说，Service层在MVC模式中属于Model层）获得所有的Em，将Em封装进List中，通过ModelAndView对象中的addObject()方法，告诉SpringMVC这是等会你做视图解析需要用到的Model数据，解析到哪个JSP中？setViewName方法已经告诉你了，解析到/WEB-INF/views文件夹下的all_em.jsp这个JSP文件（可以配置视图解析器前后缀，这样就不用写一大串了，只需要写JSP的文件名就行了）。</p>
<p>通过这个例子我们可以基本了解SpringMVC中的MVC到底是什么了，其实就是做完型填空，答案：数据（Model）；答题卡：界面模板（View）；试卷：这个空对应哪道题（Controller）；抄答案做填空：（视图解析器）。</p>
<p>拿到答题卡和试卷之后，我们先做试卷找到答案（通过Model层获取数据，查询数据库也好，自己胡编乱造也好。），看题号找到答题卡对应的位置（通过Controller将Model和View对应起来），填好答案（视图解析器），将填好的答题卡（HTML）交给老师（浏览器）。</p>
<h2 id="前后端分离下的MVC模式"><a href="#前后端分离下的MVC模式" class="headerlink" title="前后端分离下的MVC模式"></a>前后端分离下的MVC模式</h2><p>曾经的曾经JSP还在统治世界的时候，前后端分离也就是前端写界面，后端改成JSP。耦合度那叫一个高啊。经常后端改成JSP之后，界面崩了，鼻子不是鼻子，眼睛不是眼睛。前端还在家里睡觉呢，后端一个电话喊来加班一起改界面。于是前端说：这是我的界面？后端说：嗯呢，我稍微修改了一下。前端看着嵌入的JSTL说：啥啥啥，这都是啥？后端看着CSS和JavaScript说：啥啥啥，这又是啥？前端怒了，耦合度那么高，再干两年JDK更新都得请我去开会了。后端也怒了，再干两年我都得参与HTML6的研发了。</p>
<p>后来呢？MVC模式准备分家了，前后端对话如下：</p>
<p>前端：你别管我的界面了，你把数据给我，我自己加到界面里面。</p>
<p>后端：那我给你传个Java对象，你能用啊？</p>
<p>前端：大哥，能传个字符串不。</p>
<p>后端：我想想，那我们约定一个规范好了，专门用来前后端传输数据的。</p>
<p>前端：别了，这么麻烦呢？我这边准备用JavaScript渲染数据到界面上，你就给我传个JSON格式的字符串好了。</p>
<p>后端：那你怎么知道我返回的是失败的数据还是成功的数据呢？</p>
<p>前端：还记得HTTP嘛？HTTP有什么状态码还知道不？</p>
<p>后端：那我把数据、状态码、状态信息封装起来一起交给你吧。</p>
<p>前端：OKOK！</p>
<p>于是，前后端彻底分离了。</p>
<p>说这个是为了什么呢？就是为了告诉大家现在开发更加方便，我们将一部分的工作量分给了前端，所以目测最近几年前端所需要的人才缺口爆炸。这样一想……我准备转行去前端了，不写了，大家再见！</p>
<p>我回来了，他们要三年经验……</p>
<p>这里需要大家明白一点，虽然前后端分离大行其道，但是博主认为前后端分离是MVC模式的进化版本，MVC不会过时，过时的只是JSP这种前后端高度耦合的技术。</p>
<h3 id="SpringMVC实例"><a href="#SpringMVC实例" class="headerlink" title="SpringMVC实例"></a>SpringMVC实例</h3><p>博主使用的工具是idea，经常听大家说idea创建maven不好用，经过多个版本更新之后，idea现在除了收费应该没有什么短板了。</p>
<p>下面就跟着博主一步一步进行。</p>
<p>首先创建一个Maven项目</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144026841.png" alt="image-20200711144026841"></p>
<p>给项目选一个喜欢的名字。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144305974.png" alt="image-20200711144305974"></p>
<p>选择Maven的配置文件和本地仓库。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711144505757.png" alt="image-20200711144505757"></p>
<p>接下来就进入到我们的项目界面了，来看一下项目结构</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711155349934.png" alt="image-20200711155349934"></p>
<p>在web.xml中写上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">"http://java.sun.com/dtd/web-app_2_3.dtd"</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring的ApplicationContext 载入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 指定加载外部的spring-mvc配置文件 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>resources/applicationContext.xml中写上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用context命名空间，自动扫描包top.vanbyz下的类，除了Controller --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在DemoController中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> top.blooog.service.DemoService;</span><br><span class="line"><span class="keyword">import</span> top.blooog.util.AjaxResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DemoService demoService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoController</span><span class="params">(DemoService demoService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.demoService = demoService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult&lt;List&gt; <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AjaxResult&lt;List&gt; ajaxResult = <span class="keyword">new</span> AjaxResult&lt;&gt;();</span><br><span class="line">        ajaxResult.setCode((<span class="keyword">short</span>) <span class="number">200</span>);</span><br><span class="line">        ajaxResult.setData(demoService.demo());</span><br><span class="line">        ajaxResult.setMessage(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> ajaxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DemoService中写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.blooog.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"SpringMVC 你好！"</span>);</span><br><span class="line">        list.add(<span class="string">"欢迎来到我的个人博客"</span>);</span><br><span class="line">        list.add(<span class="string">"blooog.top"</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后配置Tomcat。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174426765.png" alt="image-20200711174426765"></p>
<p>像我这样配置，如果出现了红色提示，就点击Fix。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174451849.png" alt="image-20200711174451849"></p>
<p>看起来像是OK了，运行Tomcat。</p>
<p>浏览器弹出了这个界面：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174609270.png" alt="image-20200711174609270"></p>
<p>嘿？怎么不输出我们设置的数据呢？原来是路径问题，在@RequestMapping注解标注了访问这个Controller方法的路径，我们重新试一下：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711174833487.png" alt="image-20200711174833487"></p>
<p>成功报错，也就是不认识AjaxResult这玩意，SpringMVC跟我们说：你怎么能把这玩意（AjaxResult对象）塞到响应体呢？！我干不了，你再找人吧！</p>
<p>嗯……我们给SpringMVC找一个能干这个的棒小伙吧！没错，JSON解析工具！</p>
<p>我们这里使用fastjson，这是国货之光阿里巴巴的作品，在pom文件中添加：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阿里JSON解析器 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.70&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>此时需要告诉SpringMVC我们要用Fastjson组件，编辑spring-mvc.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="comment">&lt;!--将最后一行的&lt;mvc:annotation-driven/&gt;修改为--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"supportedMediaTypes"</span> <span class="attr">value</span>=<span class="string">"application/json"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>重新访问地址localhost:8080/hello</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711181251731.png" alt="image-20200711181251731"></p>
<p>搞定！</p>
<p>当然，fastjson并没有我们现在用的这么简单，后期有时间的话我会出一个详细一点的教程。</p>
<h3 id="前后端开发利器——PostMan"><a href="#前后端开发利器——PostMan" class="headerlink" title="前后端开发利器——PostMan"></a>前后端开发利器——PostMan</h3><p>前面使用了浏览器进行调试（因为没有界面……），博主又不会前端这些鬼东西，没有参数的时候还好说，像HelloWorld一样字符串直接显示在浏览器上。有参数的时候呢？例如我们的登录，又怎么验证呢？难道使用浏览器那个小小小小小的调试窗口进行测试嘛？</p>
<p>接下来我介绍一个开发利器给大家PostMan，邮差！这个软件是谷歌出品，用于后端接口测试，曾经提供谷歌浏览器插件，后来独立为一个软件。</p>
<p>可以通过<a href="https://www.postman.com/" target="_blank" rel="noopener">PostMan官网</a>进行下载，博主这里简单介绍用法。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711184608990.png" alt="image-20200711184608990"></p>
<p>可以看到响应模块中的body比浏览器中显示的更加清晰。</p>
<p>更多使用方法可以参考博客<a href="https://www.jianshu.com/p/97ba64888894" target="_blank" rel="noopener">Postman教程大全</a>，使用方法很简单，博主就不再啰嗦了。</p>
<h2 id="SpringMVC实例讲解"><a href="#SpringMVC实例讲解" class="headerlink" title="SpringMVC实例讲解"></a>SpringMVC实例讲解</h2><p>经过上面的实例，我们对SpringMVC也有了一些认识，首先就是我们需要进行一些配置，web.xml中配置dispatcherServlet和Mapping，这个Servlet是SpringMVC的总入口。还记得Servlet是什么嘛？往往我们一个Servlet代表一个功能，但是SpringMVC将所有请求（除了静态）都集中下来，交给dispatcherServlet，使用dispatcherServlet来执行我们的业务逻辑。dispatcherServlet具体内容的讲解我会在SpringMVC的原理中讲解。</p>
<p>我们都知道SpringMVC是Spring中的一个组件，所以我们本能的认为Spring和SpringMVC是无缝衔接的，来我们看applicationContext中的一个配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用context命名空间，自动扫描包top.vanbyz下的类，除了Controller --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在applicationContext配置文件中，通过&lt;context:exclude-filter&gt;标签我们让Spring不要扫描controller，而在spring-mvc.xml中，我们又重新扫描Controller。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置mvc的注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comtext:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.blooog"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">comtext:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">comtext:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>让人疑惑，这不是脱了裤子放屁，多此一举吗？我一次性全部扫描不行吗？答案当然是否定的。因为SpringMVC和Spring是两个容器，就像电影里说的一句台词：<em>朕赐给你</em>，<em>才是你的，朕不给</em>，<em>你不能抢</em>。所以Spring容器中的Controller组件没有在SpringMVC中注册，于是就会出现找不到路径这个错误。spring-mvc.xml这个配置文件时web.xml文件钦点给dispatcherServlet的，你Spring虽然是SpringMVC的父容器，但是Spring扫描到的Controller，SpringMVC容器中并没有，也就无法使用。</p>
<p>实例中还使用了大量的注解，来看看我们使用了哪些注解……</p>
<p><strong>Controller：</strong>这个就不用多说了吧，用于扫描Controller组件的。</p>
<p><strong>RequestMapping：</strong>见名知其意，一眼就看出来是用来映射的，值得注意的是这个注解不仅可以标注在方法上，还可以标注在类上，这样这个Controller所有的方法默认前缀都加上了一个类RequestMapping值，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"class"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AjaxResult&lt;List&gt; <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        AjaxResult&lt;List&gt; ajaxResult = <span class="keyword">new</span> AjaxResult&lt;&gt;();</span><br><span class="line">        ajaxResult.setCode((<span class="keyword">short</span>) <span class="number">200</span>);</span><br><span class="line">        ajaxResult.setData(demoService.demo());</span><br><span class="line">        ajaxResult.setMessage(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> ajaxResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，访问hello方法的url就是localhost:8080/class/hello。</p>
<p>说完value了，这个method又是什么玩意呢？这是RestFul风格的产物，简单说一下Restful风格吧：</p>
<p>RestFul风格是一种风格，而不是一种规范，就像我们左大括号写在类或者方法同一行，你可以不遵守，但是遵守了会优雅很多（大家协同工作，风格就是规范！）。这个风格要求什么呢？</p>
<ol>
<li>每一个url代表一个资源，比如user、session等等</li>
<li>使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源；POST用来新建资源；PUT用来更新资源；DELETE用来删除资源；</li>
</ol>
<p>还有其他要求，希望大家自行查阅，这里不再赘述。</p>
<p>可能有的同学没有看懂，那么我再解释一下：我们的需要对A资源进行获取操作，那么我们的url就是localhost:8080/A/。而不是localhost:8080/getA/。那么有同学问了，我如果要对A资源进行增加操作呢？还使用localhost:8080/A/不就撞了吗？Restful微微一笑，少年，你学过方法的重载吗？Java方法的重载是方法同名不同参，我Restful是同链不同方法。也就是相同的url，因为浏览器发出请求的方法不同，所调用Controller中的方法也不同。</p>
<p>实例中采用的是get方法，我们通过PostMan发出get方法的请求可以接收到返回的数据，如果我们发送post请求呢？</p>
<p>在方法下拉栏里选择post然后send</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711211759296.png" alt="image-20200711211759296"></p>
<p>返回一长串响应体：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP Status 405 – 方法不允许<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="xml">	<span class="comment">&lt;!--省略--&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTTP Status 405 – 方法不允许<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"line"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>Type<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Status Report<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">b</span>&gt;</span> Request method <span class="symbol">&amp;#39;</span>POST<span class="symbol">&amp;#39;</span> not supported<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>描述<span class="tag">&lt;/<span class="name">b</span>&gt;</span> 请求行中接收的方法由源服务器知道，但目标资源不支持<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"line"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Apache Tomcat/9.0.33<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>报了405错误，我们都知道4xx开头的都是资源找不到，因为我们没有为hello这个资源定义method=post的RequestMapping。</p>
<p>我们在Controller中加上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"hello"</span>,method = RequestMethod.DELETE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"delete!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后通过PostMan的发出请求</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200711214718197.png" alt="image-20200711214718197"></p>
<p>成功获取到想要的值。</p>
<p><strong>*注意：</strong>PostMan可以直接发送各种方法的请求，不代表浏览器也可以，HTML中的form表单仅支持get和post两种请求，需要在web.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个过滤器会将下面的form表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"put"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"userInfo"</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line">或者</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"userInfo"</span> <span class="attr">action</span>=<span class="string">"/xxx/xxx"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"delete"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是将form表单不支持的方法，变为参数通过post传递过去。</p>
<p>因为顺便讲了Restful的关系，RequestMapping占了很大的篇幅，希望大家还没有失去耐心。再给大家一个RequestMapping的省事小技巧：</p>
<blockquote>
<p> @RequestMapping(value = “hello”,method = RequestMethod.GET) </p>
<p> 可以转变为</p>
<p> @GetMapping(“hello”)</p>
</blockquote>
<p>同理其他几个方法也可以转变为XXXMapping的格式。</p>
<p><strong>ResponseBody：</strong>这个注解可以标注在方法和类上，标注在方法上说明方法的返回值将作为HTTP的响应体返回给浏览器，同理，标注在类上就说明这个Controller类的所有方法的头上都有了一个@ResponseBody，再来一个小技巧：</p>
<blockquote>
<p>@Controller</p>
<p>@ResponseBody</p>
<p>可以简写为</p>
<p>@RestController</p>
</blockquote>
<p>这个注解没什么好说的，只要记住被标注的方法返回值会被写进HTTP响应体中，如果没有JSON解析就会报错，因为SpringMVC也不知道你返回个Java对象怎么传。</p>
<p>我们见过的所有注解都已经讲完了，下面该讲一些我们没见过的注解了。</p>
<p>怎么获取浏览器发给我们的参数呢？</p>
<p>三种办法：form表单、Ajax提交和url，form和url我们都很熟悉，Ajax就是前端的事情啦。form就不讲了，这里讲讲Ajax，虽然Ajax是前端的事情，但是作为后端开发人员，学习Ajax还是有必要的。</p>
<p>先讲一讲Ajax提交请求，Ajax将数据封装JSON字符串到HTTP请求体中，然后提交给服务器。所以我们可以使用功能强大的PostMan模仿Ajax提交请求。</p>
<p>这里涉及到一个注解<strong>@RequestBody</strong></p>
<p>在上一实例的基础上创建一个实体类entity.User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age='"</span> + age + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//别忘了写getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在DemoController添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult&lt;User&gt; <span class="title">getUser</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user.toString());</span><br><span class="line">    user.setAge(<span class="string">"22"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult&lt;User&gt;((<span class="keyword">short</span>) <span class="number">200</span>,<span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新运行Tomcat</p>
<p>打开PostMan，设置请求体文本类型为json</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002118022.png" alt="image-20200712002118022"></p>
<p>点击Body -&gt; raw </p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712001319890.png" alt="image-20200712001319890"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"userName"</span>:<span class="string">"zhouxx"</span>,</span><br><span class="line">    <span class="attr">"address"</span>:<span class="string">"blooog.top"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="string">"21"</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"123456"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置好之后点击send。</p>
<p>Idea控制台出现：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002345055.png" alt="image-20200712002345055"></p>
<p>PostMan响应界面出现</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712002421678.png" alt="image-20200712002421678"></p>
<p>可以看到，Ajax将数据通过JSON字符串传递过去，通过@RequestBody注解 -&gt; fastjson 转化User对象。至此服务器接收Ajax请求完成。</p>
<p>form表单提交涉及到一个注解——<strong>@RequestParam</strong>，这个注解的使用方法也特别简单，看下面的例子：</p>
<p>html/jsp的form表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath&#125;/user/login.do"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"num"</span> <span class="attr">placeholder</span>=<span class="string">"手机号"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"密码"</span>/&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"num"</span>)</span> String num,</span></span><br><span class="line"><span class="function">                   @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password,</span></span><br><span class="line"><span class="function">                   HttpSession session) </span>&#123;</span><br><span class="line">    User user = userService.login(num, password);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        session.setAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        modelAndView.setViewName(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RequestParam中的value和表单中的input中的name一致。</p>
<p>Restful风格也可以使用url传递参数，例如localhost:8080/user/1就是对id=1的user进行操作。使用<strong>@PathVariable</strong>可以实现：</p>
<p>我们在原来例子中的Controller上添加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>( <span class="string">"user/&#123;userName&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxResult&lt;User&gt; <span class="title">pathTest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @PathVariable(value = <span class="string">"userName"</span>)</span> String userName) </span>&#123;</span><br><span class="line">    System.out.println(userName);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AjaxResult&lt;User&gt;((<span class="keyword">short</span>) <span class="number">200</span>, <span class="string">"success"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启Tomcat。</p>
<p>打开我们的PostMan，输入URL，把之前Body中的内容删除。</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095515714.png" alt="image-20200712095515714"></p>
<p>Body上会有一个小绿点，提示里面有内容。</p>
<p>点击Send按钮发送请求。控制台显示：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095617698.png" alt="image-20200712095617698"></p>
<p>PostMan界面显示：</p>
<p><img src="https://gitee.com/vanbyz/images/raw/master/img/image-20200712095808638.png" alt="image-20200712095808638"></p>
<h2 id="注解总结"><a href="#注解总结" class="headerlink" title="注解总结"></a>注解总结</h2><p>讲到这里大家歇一歇，我来总结一下上面接触到的注解。</p>
<p>与请求接收数据相关的有：</p>
<p>@RequestBody：接收JSON请求体，用法：标注在方法头上</p>
<p>@PathVariable：接收URL上的值，用法：标注在方法参数上，如果参数是对象，那么会根据setter方法自动注入</p>
<p>@RequestParam：接收Form表单的数据，用法：标注在方法参数前面</p>
<p>与返回数据相关的有：</p>
<p>@ResponseBody：将返回值作为HTTP的响应体，用法标注在类或者方法头上。</p>
<p>@RestController：可以看作是@Controller和@ResponseBody的结合</p>
<p>与路径相关的有：</p>
<p>@RequestMapping：可以标注在类或者方法上，值为该请求 -&gt; 方法的路径，标注在类上则为这个类中所有的方法加上前缀。</p>
<p>@GetMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为get。</p>
<p>@PostMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为post。</p>
<p>@PutMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为put。</p>
<p>@DeleteMapping：标注在方法上，值为该请求 -&gt; 方法的路径，请求的方法名为delete。</p>
<h2 id="搞定完结"><a href="#搞定完结" class="headerlink" title="搞定完结"></a>搞定完结</h2><p>缕一缕这篇博客讲了什么：</p>
<ol>
<li>MVC是个啥</li>
<li>前后端分离的故事</li>
<li>SpringMVC和Spring不得不说的配置</li>
<li>优雅的Restful风格</li>
<li>开发利器PostMan</li>
<li>SpringMVC注解大家庭</li>
</ol>
<p>希望你能根据这6条回忆起这篇博客的内容。</p>
<p>这篇博客对HTTP协议、Servlet有一丢丢丢的要求，如果你看起来很吃力或者有任何疑问，欢迎询问。</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
</search>
